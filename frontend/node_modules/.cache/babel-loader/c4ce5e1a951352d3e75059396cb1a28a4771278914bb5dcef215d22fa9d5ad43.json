{"ast":null,"code":"import WebSocketFactory from './lib/websocket-factory';\nimport { CHANNEL_EVENTS, CONNECTION_STATE, DEFAULT_VERSION, DEFAULT_TIMEOUT, SOCKET_STATES, TRANSPORTS, DEFAULT_VSN, VSN_1_0_0, VSN_2_0_0, WS_CLOSE_NORMAL } from './lib/constants';\nimport Serializer from './lib/serializer';\nimport Timer from './lib/timer';\nimport { httpEndpointURL } from './lib/transformers';\nimport RealtimeChannel from './RealtimeChannel';\nconst noop = () => {};\n// Connection-related constants\nconst CONNECTION_TIMEOUTS = {\n  HEARTBEAT_INTERVAL: 25000,\n  RECONNECT_DELAY: 10,\n  HEARTBEAT_TIMEOUT_FALLBACK: 100\n};\nconst RECONNECT_INTERVALS = [1000, 2000, 5000, 10000];\nconst DEFAULT_RECONNECT_FALLBACK = 10000;\nconst WORKER_SCRIPT = `\n  addEventListener(\"message\", (e) => {\n    if (e.data.event === \"start\") {\n      setInterval(() => postMessage({ event: \"keepAlive\" }), e.data.interval);\n    }\n  });`;\nexport default class RealtimeClient {\n  /**\r\n   * Initializes the Socket.\r\n   *\r\n   * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\r\n   * @param httpEndpoint The string HTTP endpoint, ie, \"https://example.com\", \"/\" (inherited host & protocol)\r\n   * @param options.transport The Websocket Transport, for example WebSocket. This can be a custom implementation\r\n   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\r\n   * @param options.params The optional params to pass when connecting.\r\n   * @param options.headers Deprecated: headers cannot be set on websocket connections and this option will be removed in the future.\r\n   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\r\n   * @param options.heartbeatCallback The optional function to handle heartbeat status and latency.\r\n   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\r\n   * @param options.logLevel Sets the log level for Realtime\r\n   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\r\n   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\r\n   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\r\n   * @param options.worker Use Web Worker to set a side flow. Defaults to false.\r\n   * @param options.workerUrl The URL of the worker script. Defaults to https://realtime.supabase.com/worker.js that includes a heartbeat event call to keep the connection alive.\r\n   * @param options.vsn The protocol version to use when connecting. Supported versions are \"1.0.0\" and \"2.0.0\". Defaults to \"2.0.0\".\r\n   * @example\r\n   * ```ts\r\n   * import RealtimeClient from '@supabase/realtime-js'\r\n   *\r\n   * const client = new RealtimeClient('https://xyzcompany.supabase.co/realtime/v1', {\r\n   *   params: { apikey: 'public-anon-key' },\r\n   * })\r\n   * client.connect()\r\n   * ```\r\n   */\n  constructor(endPoint, options) {\n    var _a;\n    this.accessTokenValue = null;\n    this.apiKey = null;\n    this._manuallySetToken = false;\n    this.channels = new Array();\n    this.endPoint = '';\n    this.httpEndpoint = '';\n    /** @deprecated headers cannot be set on websocket connections */\n    this.headers = {};\n    this.params = {};\n    this.timeout = DEFAULT_TIMEOUT;\n    this.transport = null;\n    this.heartbeatIntervalMs = CONNECTION_TIMEOUTS.HEARTBEAT_INTERVAL;\n    this.heartbeatTimer = undefined;\n    this.pendingHeartbeatRef = null;\n    this.heartbeatCallback = noop;\n    this.ref = 0;\n    this.reconnectTimer = null;\n    this.vsn = DEFAULT_VSN;\n    this.logger = noop;\n    this.conn = null;\n    this.sendBuffer = [];\n    this.serializer = new Serializer();\n    this.stateChangeCallbacks = {\n      open: [],\n      close: [],\n      error: [],\n      message: []\n    };\n    this.accessToken = null;\n    this._connectionState = 'disconnected';\n    this._wasManualDisconnect = false;\n    this._authPromise = null;\n    this._heartbeatSentAt = null;\n    /**\r\n     * Use either custom fetch, if provided, or default fetch to make HTTP requests\r\n     *\r\n     * @internal\r\n     */\n    this._resolveFetch = customFetch => {\n      if (customFetch) {\n        return (...args) => customFetch(...args);\n      }\n      return (...args) => fetch(...args);\n    };\n    // Validate required parameters\n    if (!((_a = options === null || options === void 0 ? void 0 : options.params) === null || _a === void 0 ? void 0 : _a.apikey)) {\n      throw new Error('API key is required to connect to Realtime');\n    }\n    this.apiKey = options.params.apikey;\n    // Initialize endpoint URLs\n    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;\n    this.httpEndpoint = httpEndpointURL(endPoint);\n    this._initializeOptions(options);\n    this._setupReconnectionTimer();\n    this.fetch = this._resolveFetch(options === null || options === void 0 ? void 0 : options.fetch);\n  }\n  /**\r\n   * Connects the socket, unless already connected.\r\n   */\n  connect() {\n    // Skip if already connecting, disconnecting, or connected\n    if (this.isConnecting() || this.isDisconnecting() || this.conn !== null && this.isConnected()) {\n      return;\n    }\n    this._setConnectionState('connecting');\n    // Trigger auth if needed and not already in progress\n    // This ensures auth is called for standalone RealtimeClient usage\n    // while avoiding race conditions with SupabaseClient's immediate setAuth call\n    if (this.accessToken && !this._authPromise) {\n      this._setAuthSafely('connect');\n    }\n    // Establish WebSocket connection\n    if (this.transport) {\n      // Use custom transport if provided\n      this.conn = new this.transport(this.endpointURL());\n    } else {\n      // Try to use native WebSocket\n      try {\n        this.conn = WebSocketFactory.createWebSocket(this.endpointURL());\n      } catch (error) {\n        this._setConnectionState('disconnected');\n        const errorMessage = error.message;\n        // Provide helpful error message based on environment\n        if (errorMessage.includes('Node.js')) {\n          throw new Error(`${errorMessage}\\n\\n` + 'To use Realtime in Node.js, you need to provide a WebSocket implementation:\\n\\n' + 'Option 1: Use Node.js 22+ which has native WebSocket support\\n' + 'Option 2: Install and provide the \"ws\" package:\\n\\n' + '  npm install ws\\n\\n' + '  import ws from \"ws\"\\n' + '  const client = new RealtimeClient(url, {\\n' + '    ...options,\\n' + '    transport: ws\\n' + '  })');\n        }\n        throw new Error(`WebSocket not available: ${errorMessage}`);\n      }\n    }\n    this._setupConnectionHandlers();\n  }\n  /**\r\n   * Returns the URL of the websocket.\r\n   * @returns string The URL of the websocket.\r\n   */\n  endpointURL() {\n    return this._appendParams(this.endPoint, Object.assign({}, this.params, {\n      vsn: this.vsn\n    }));\n  }\n  /**\r\n   * Disconnects the socket.\r\n   *\r\n   * @param code A numeric status code to send on disconnect.\r\n   * @param reason A custom reason for the disconnect.\r\n   */\n  disconnect(code, reason) {\n    if (this.isDisconnecting()) {\n      return;\n    }\n    this._setConnectionState('disconnecting', true);\n    if (this.conn) {\n      // Setup fallback timer to prevent hanging in disconnecting state\n      const fallbackTimer = setTimeout(() => {\n        this._setConnectionState('disconnected');\n      }, 100);\n      this.conn.onclose = () => {\n        clearTimeout(fallbackTimer);\n        this._setConnectionState('disconnected');\n      };\n      // Close the WebSocket connection if close method exists\n      if (typeof this.conn.close === 'function') {\n        if (code) {\n          this.conn.close(code, reason !== null && reason !== void 0 ? reason : '');\n        } else {\n          this.conn.close();\n        }\n      }\n      this._teardownConnection();\n    } else {\n      this._setConnectionState('disconnected');\n    }\n  }\n  /**\r\n   * Returns all created channels\r\n   */\n  getChannels() {\n    return this.channels;\n  }\n  /**\r\n   * Unsubscribes and removes a single channel\r\n   * @param channel A RealtimeChannel instance\r\n   */\n  async removeChannel(channel) {\n    const status = await channel.unsubscribe();\n    if (this.channels.length === 0) {\n      this.disconnect();\n    }\n    return status;\n  }\n  /**\r\n   * Unsubscribes and removes all channels\r\n   */\n  async removeAllChannels() {\n    const values_1 = await Promise.all(this.channels.map(channel => channel.unsubscribe()));\n    this.channels = [];\n    this.disconnect();\n    return values_1;\n  }\n  /**\r\n   * Logs the message.\r\n   *\r\n   * For customized logging, `this.logger` can be overridden.\r\n   */\n  log(kind, msg, data) {\n    this.logger(kind, msg, data);\n  }\n  /**\r\n   * Returns the current state of the socket.\r\n   */\n  connectionState() {\n    switch (this.conn && this.conn.readyState) {\n      case SOCKET_STATES.connecting:\n        return CONNECTION_STATE.Connecting;\n      case SOCKET_STATES.open:\n        return CONNECTION_STATE.Open;\n      case SOCKET_STATES.closing:\n        return CONNECTION_STATE.Closing;\n      default:\n        return CONNECTION_STATE.Closed;\n    }\n  }\n  /**\r\n   * Returns `true` is the connection is open.\r\n   */\n  isConnected() {\n    return this.connectionState() === CONNECTION_STATE.Open;\n  }\n  /**\r\n   * Returns `true` if the connection is currently connecting.\r\n   */\n  isConnecting() {\n    return this._connectionState === 'connecting';\n  }\n  /**\r\n   * Returns `true` if the connection is currently disconnecting.\r\n   */\n  isDisconnecting() {\n    return this._connectionState === 'disconnecting';\n  }\n  /**\r\n   * Creates (or reuses) a {@link RealtimeChannel} for the provided topic.\r\n   *\r\n   * Topics are automatically prefixed with `realtime:` to match the Realtime service.\r\n   * If a channel with the same topic already exists it will be returned instead of creating\r\n   * a duplicate connection.\r\n   */\n  channel(topic, params = {\n    config: {}\n  }) {\n    const realtimeTopic = `realtime:${topic}`;\n    const exists = this.getChannels().find(c => c.topic === realtimeTopic);\n    if (!exists) {\n      const chan = new RealtimeChannel(`realtime:${topic}`, params, this);\n      this.channels.push(chan);\n      return chan;\n    } else {\n      return exists;\n    }\n  }\n  /**\r\n   * Push out a message if the socket is connected.\r\n   *\r\n   * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\r\n   */\n  push(data) {\n    const {\n      topic,\n      event,\n      payload,\n      ref\n    } = data;\n    const callback = () => {\n      this.encode(data, result => {\n        var _a;\n        (_a = this.conn) === null || _a === void 0 ? void 0 : _a.send(result);\n      });\n    };\n    this.log('push', `${topic} ${event} (${ref})`, payload);\n    if (this.isConnected()) {\n      callback();\n    } else {\n      this.sendBuffer.push(callback);\n    }\n  }\n  /**\r\n   * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\r\n   *\r\n   * If param is null it will use the `accessToken` callback function or the token set on the client.\r\n   *\r\n   * On callback used, it will set the value of the token internal to the client.\r\n   *\r\n   * When a token is explicitly provided, it will be preserved across channel operations\r\n   * (including removeChannel and resubscribe). The `accessToken` callback will not be\r\n   * invoked until `setAuth()` is called without arguments.\r\n   *\r\n   * @param token A JWT string to override the token set on the client.\r\n   *\r\n   * @example\r\n   * // Use a manual token (preserved across resubscribes, ignores accessToken callback)\r\n   * client.realtime.setAuth('my-custom-jwt')\r\n   *\r\n   * // Switch back to using the accessToken callback\r\n   * client.realtime.setAuth()\r\n   */\n  async setAuth(token = null) {\n    this._authPromise = this._performAuth(token);\n    try {\n      await this._authPromise;\n    } finally {\n      this._authPromise = null;\n    }\n  }\n  /**\r\n   * Returns true if the current access token was explicitly set via setAuth(token),\r\n   * false if it was obtained via the accessToken callback.\r\n   * @internal\r\n   */\n  _isManualToken() {\n    return this._manuallySetToken;\n  }\n  /**\r\n   * Sends a heartbeat message if the socket is connected.\r\n   */\n  async sendHeartbeat() {\n    var _a;\n    if (!this.isConnected()) {\n      try {\n        this.heartbeatCallback('disconnected');\n      } catch (e) {\n        this.log('error', 'error in heartbeat callback', e);\n      }\n      return;\n    }\n    // Handle heartbeat timeout and force reconnection if needed\n    if (this.pendingHeartbeatRef) {\n      this.pendingHeartbeatRef = null;\n      this._heartbeatSentAt = null;\n      this.log('transport', 'heartbeat timeout. Attempting to re-establish connection');\n      try {\n        this.heartbeatCallback('timeout');\n      } catch (e) {\n        this.log('error', 'error in heartbeat callback', e);\n      }\n      // Force reconnection after heartbeat timeout\n      this._wasManualDisconnect = false;\n      (_a = this.conn) === null || _a === void 0 ? void 0 : _a.close(WS_CLOSE_NORMAL, 'heartbeat timeout');\n      setTimeout(() => {\n        var _a;\n        if (!this.isConnected()) {\n          (_a = this.reconnectTimer) === null || _a === void 0 ? void 0 : _a.scheduleTimeout();\n        }\n      }, CONNECTION_TIMEOUTS.HEARTBEAT_TIMEOUT_FALLBACK);\n      return;\n    }\n    // Send heartbeat message to server\n    this._heartbeatSentAt = Date.now();\n    this.pendingHeartbeatRef = this._makeRef();\n    this.push({\n      topic: 'phoenix',\n      event: 'heartbeat',\n      payload: {},\n      ref: this.pendingHeartbeatRef\n    });\n    try {\n      this.heartbeatCallback('sent');\n    } catch (e) {\n      this.log('error', 'error in heartbeat callback', e);\n    }\n    this._setAuthSafely('heartbeat');\n  }\n  /**\r\n   * Sets a callback that receives lifecycle events for internal heartbeat messages.\r\n   * Useful for instrumenting connection health (e.g. sent/ok/timeout/disconnected).\r\n   */\n  onHeartbeat(callback) {\n    this.heartbeatCallback = callback;\n  }\n  /**\r\n   * Flushes send buffer\r\n   */\n  flushSendBuffer() {\n    if (this.isConnected() && this.sendBuffer.length > 0) {\n      this.sendBuffer.forEach(callback => callback());\n      this.sendBuffer = [];\n    }\n  }\n  /**\r\n   * Return the next message ref, accounting for overflows\r\n   *\r\n   * @internal\r\n   */\n  _makeRef() {\n    let newRef = this.ref + 1;\n    if (newRef === this.ref) {\n      this.ref = 0;\n    } else {\n      this.ref = newRef;\n    }\n    return this.ref.toString();\n  }\n  /**\r\n   * Unsubscribe from channels with the specified topic.\r\n   *\r\n   * @internal\r\n   */\n  _leaveOpenTopic(topic) {\n    let dupChannel = this.channels.find(c => c.topic === topic && (c._isJoined() || c._isJoining()));\n    if (dupChannel) {\n      this.log('transport', `leaving duplicate topic \"${topic}\"`);\n      dupChannel.unsubscribe();\n    }\n  }\n  /**\r\n   * Removes a subscription from the socket.\r\n   *\r\n   * @param channel An open subscription.\r\n   *\r\n   * @internal\r\n   */\n  _remove(channel) {\n    this.channels = this.channels.filter(c => c.topic !== channel.topic);\n  }\n  /** @internal */\n  _onConnMessage(rawMessage) {\n    this.decode(rawMessage.data, msg => {\n      // Handle heartbeat responses\n      if (msg.topic === 'phoenix' && msg.event === 'phx_reply' && msg.ref && msg.ref === this.pendingHeartbeatRef) {\n        const latency = this._heartbeatSentAt ? Date.now() - this._heartbeatSentAt : undefined;\n        try {\n          this.heartbeatCallback(msg.payload.status === 'ok' ? 'ok' : 'error', latency);\n        } catch (e) {\n          this.log('error', 'error in heartbeat callback', e);\n        }\n        this._heartbeatSentAt = null;\n        this.pendingHeartbeatRef = null;\n      }\n      // Log incoming message\n      const {\n        topic,\n        event,\n        payload,\n        ref\n      } = msg;\n      const refString = ref ? `(${ref})` : '';\n      const status = payload.status || '';\n      this.log('receive', `${status} ${topic} ${event} ${refString}`.trim(), payload);\n      // Route message to appropriate channels\n      this.channels.filter(channel => channel._isMember(topic)).forEach(channel => channel._trigger(event, payload, ref));\n      this._triggerStateCallbacks('message', msg);\n    });\n  }\n  /**\r\n   * Clear specific timer\r\n   * @internal\r\n   */\n  _clearTimer(timer) {\n    var _a;\n    if (timer === 'heartbeat' && this.heartbeatTimer) {\n      clearInterval(this.heartbeatTimer);\n      this.heartbeatTimer = undefined;\n    } else if (timer === 'reconnect') {\n      (_a = this.reconnectTimer) === null || _a === void 0 ? void 0 : _a.reset();\n    }\n  }\n  /**\r\n   * Clear all timers\r\n   * @internal\r\n   */\n  _clearAllTimers() {\n    this._clearTimer('heartbeat');\n    this._clearTimer('reconnect');\n  }\n  /**\r\n   * Setup connection handlers for WebSocket events\r\n   * @internal\r\n   */\n  _setupConnectionHandlers() {\n    if (!this.conn) return;\n    // Set binary type if supported (browsers and most WebSocket implementations)\n    if ('binaryType' in this.conn) {\n      ;\n      this.conn.binaryType = 'arraybuffer';\n    }\n    this.conn.onopen = () => this._onConnOpen();\n    this.conn.onerror = error => this._onConnError(error);\n    this.conn.onmessage = event => this._onConnMessage(event);\n    this.conn.onclose = event => this._onConnClose(event);\n    if (this.conn.readyState === SOCKET_STATES.open) {\n      this._onConnOpen();\n    }\n  }\n  /**\r\n   * Teardown connection and cleanup resources\r\n   * @internal\r\n   */\n  _teardownConnection() {\n    if (this.conn) {\n      if (this.conn.readyState === SOCKET_STATES.open || this.conn.readyState === SOCKET_STATES.connecting) {\n        try {\n          this.conn.close();\n        } catch (e) {\n          this.log('error', 'Error closing connection', e);\n        }\n      }\n      this.conn.onopen = null;\n      this.conn.onerror = null;\n      this.conn.onmessage = null;\n      this.conn.onclose = null;\n      this.conn = null;\n    }\n    this._clearAllTimers();\n    this._terminateWorker();\n    this.channels.forEach(channel => channel.teardown());\n  }\n  /** @internal */\n  _onConnOpen() {\n    this._setConnectionState('connected');\n    this.log('transport', `connected to ${this.endpointURL()}`);\n    // Wait for any pending auth operations before flushing send buffer\n    // This ensures channel join messages include the correct access token\n    const authPromise = this._authPromise || (this.accessToken && !this.accessTokenValue ? this.setAuth() : Promise.resolve());\n    authPromise.then(() => {\n      this.flushSendBuffer();\n    }).catch(e => {\n      this.log('error', 'error waiting for auth on connect', e);\n      // Proceed anyway to avoid hanging connections\n      this.flushSendBuffer();\n    });\n    this._clearTimer('reconnect');\n    if (!this.worker) {\n      this._startHeartbeat();\n    } else {\n      if (!this.workerRef) {\n        this._startWorkerHeartbeat();\n      }\n    }\n    this._triggerStateCallbacks('open');\n  }\n  /** @internal */\n  _startHeartbeat() {\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n    this.heartbeatTimer = setInterval(() => this.sendHeartbeat(), this.heartbeatIntervalMs);\n  }\n  /** @internal */\n  _startWorkerHeartbeat() {\n    if (this.workerUrl) {\n      this.log('worker', `starting worker for from ${this.workerUrl}`);\n    } else {\n      this.log('worker', `starting default worker`);\n    }\n    const objectUrl = this._workerObjectUrl(this.workerUrl);\n    this.workerRef = new Worker(objectUrl);\n    this.workerRef.onerror = error => {\n      this.log('worker', 'worker error', error.message);\n      this._terminateWorker();\n    };\n    this.workerRef.onmessage = event => {\n      if (event.data.event === 'keepAlive') {\n        this.sendHeartbeat();\n      }\n    };\n    this.workerRef.postMessage({\n      event: 'start',\n      interval: this.heartbeatIntervalMs\n    });\n  }\n  /**\r\n   * Terminate the Web Worker and clear the reference\r\n   * @internal\r\n   */\n  _terminateWorker() {\n    if (this.workerRef) {\n      this.log('worker', 'terminating worker');\n      this.workerRef.terminate();\n      this.workerRef = undefined;\n    }\n  }\n  /** @internal */\n  _onConnClose(event) {\n    var _a;\n    this._setConnectionState('disconnected');\n    this.log('transport', 'close', event);\n    this._triggerChanError();\n    this._clearTimer('heartbeat');\n    // Only schedule reconnection if it wasn't a manual disconnect\n    if (!this._wasManualDisconnect) {\n      (_a = this.reconnectTimer) === null || _a === void 0 ? void 0 : _a.scheduleTimeout();\n    }\n    this._triggerStateCallbacks('close', event);\n  }\n  /** @internal */\n  _onConnError(error) {\n    this._setConnectionState('disconnected');\n    this.log('transport', `${error}`);\n    this._triggerChanError();\n    this._triggerStateCallbacks('error', error);\n    try {\n      this.heartbeatCallback('error');\n    } catch (e) {\n      this.log('error', 'error in heartbeat callback', e);\n    }\n  }\n  /** @internal */\n  _triggerChanError() {\n    this.channels.forEach(channel => channel._trigger(CHANNEL_EVENTS.error));\n  }\n  /** @internal */\n  _appendParams(url, params) {\n    if (Object.keys(params).length === 0) {\n      return url;\n    }\n    const prefix = url.match(/\\?/) ? '&' : '?';\n    const query = new URLSearchParams(params);\n    return `${url}${prefix}${query}`;\n  }\n  _workerObjectUrl(url) {\n    let result_url;\n    if (url) {\n      result_url = url;\n    } else {\n      const blob = new Blob([WORKER_SCRIPT], {\n        type: 'application/javascript'\n      });\n      result_url = URL.createObjectURL(blob);\n    }\n    return result_url;\n  }\n  /**\r\n   * Set connection state with proper state management\r\n   * @internal\r\n   */\n  _setConnectionState(state, manual = false) {\n    this._connectionState = state;\n    if (state === 'connecting') {\n      this._wasManualDisconnect = false;\n    } else if (state === 'disconnecting') {\n      this._wasManualDisconnect = manual;\n    }\n  }\n  /**\r\n   * Perform the actual auth operation\r\n   * @internal\r\n   */\n  async _performAuth(token = null) {\n    let tokenToSend;\n    let isManualToken = false;\n    if (token) {\n      tokenToSend = token;\n      // Track if this is a manually-provided token\n      isManualToken = true;\n    } else if (this.accessToken) {\n      // Call the accessToken callback to get fresh token\n      try {\n        tokenToSend = await this.accessToken();\n      } catch (e) {\n        this.log('error', 'Error fetching access token from callback', e);\n        // Fall back to cached value if callback fails\n        tokenToSend = this.accessTokenValue;\n      }\n    } else {\n      tokenToSend = this.accessTokenValue;\n    }\n    // Track whether this token was manually set or fetched via callback\n    if (isManualToken) {\n      this._manuallySetToken = true;\n    } else if (this.accessToken) {\n      // If we used the callback, clear the manual flag\n      this._manuallySetToken = false;\n    }\n    if (this.accessTokenValue != tokenToSend) {\n      this.accessTokenValue = tokenToSend;\n      this.channels.forEach(channel => {\n        const payload = {\n          access_token: tokenToSend,\n          version: DEFAULT_VERSION\n        };\n        tokenToSend && channel.updateJoinPayload(payload);\n        if (channel.joinedOnce && channel._isJoined()) {\n          channel._push(CHANNEL_EVENTS.access_token, {\n            access_token: tokenToSend\n          });\n        }\n      });\n    }\n  }\n  /**\r\n   * Wait for any in-flight auth operations to complete\r\n   * @internal\r\n   */\n  async _waitForAuthIfNeeded() {\n    if (this._authPromise) {\n      await this._authPromise;\n    }\n  }\n  /**\r\n   * Safely call setAuth with standardized error handling\r\n   * @internal\r\n   */\n  _setAuthSafely(context = 'general') {\n    // Only refresh auth if using callback-based tokens\n    if (!this._isManualToken()) {\n      this.setAuth().catch(e => {\n        this.log('error', `Error setting auth in ${context}`, e);\n      });\n    }\n  }\n  /**\r\n   * Trigger state change callbacks with proper error handling\r\n   * @internal\r\n   */\n  _triggerStateCallbacks(event, data) {\n    try {\n      this.stateChangeCallbacks[event].forEach(callback => {\n        try {\n          callback(data);\n        } catch (e) {\n          this.log('error', `error in ${event} callback`, e);\n        }\n      });\n    } catch (e) {\n      this.log('error', `error triggering ${event} callbacks`, e);\n    }\n  }\n  /**\r\n   * Setup reconnection timer with proper configuration\r\n   * @internal\r\n   */\n  _setupReconnectionTimer() {\n    this.reconnectTimer = new Timer(async () => {\n      setTimeout(async () => {\n        await this._waitForAuthIfNeeded();\n        if (!this.isConnected()) {\n          this.connect();\n        }\n      }, CONNECTION_TIMEOUTS.RECONNECT_DELAY);\n    }, this.reconnectAfterMs);\n  }\n  /**\r\n   * Initialize client options with defaults\r\n   * @internal\r\n   */\n  _initializeOptions(options) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;\n    // Set defaults\n    this.transport = (_a = options === null || options === void 0 ? void 0 : options.transport) !== null && _a !== void 0 ? _a : null;\n    this.timeout = (_b = options === null || options === void 0 ? void 0 : options.timeout) !== null && _b !== void 0 ? _b : DEFAULT_TIMEOUT;\n    this.heartbeatIntervalMs = (_c = options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs) !== null && _c !== void 0 ? _c : CONNECTION_TIMEOUTS.HEARTBEAT_INTERVAL;\n    this.worker = (_d = options === null || options === void 0 ? void 0 : options.worker) !== null && _d !== void 0 ? _d : false;\n    this.accessToken = (_e = options === null || options === void 0 ? void 0 : options.accessToken) !== null && _e !== void 0 ? _e : null;\n    this.heartbeatCallback = (_f = options === null || options === void 0 ? void 0 : options.heartbeatCallback) !== null && _f !== void 0 ? _f : noop;\n    this.vsn = (_g = options === null || options === void 0 ? void 0 : options.vsn) !== null && _g !== void 0 ? _g : DEFAULT_VSN;\n    // Handle special cases\n    if (options === null || options === void 0 ? void 0 : options.params) this.params = options.params;\n    if (options === null || options === void 0 ? void 0 : options.logger) this.logger = options.logger;\n    if ((options === null || options === void 0 ? void 0 : options.logLevel) || (options === null || options === void 0 ? void 0 : options.log_level)) {\n      this.logLevel = options.logLevel || options.log_level;\n      this.params = Object.assign(Object.assign({}, this.params), {\n        log_level: this.logLevel\n      });\n    }\n    // Set up functions with defaults\n    this.reconnectAfterMs = (_h = options === null || options === void 0 ? void 0 : options.reconnectAfterMs) !== null && _h !== void 0 ? _h : tries => {\n      return RECONNECT_INTERVALS[tries - 1] || DEFAULT_RECONNECT_FALLBACK;\n    };\n    switch (this.vsn) {\n      case VSN_1_0_0:\n        this.encode = (_j = options === null || options === void 0 ? void 0 : options.encode) !== null && _j !== void 0 ? _j : (payload, callback) => {\n          return callback(JSON.stringify(payload));\n        };\n        this.decode = (_k = options === null || options === void 0 ? void 0 : options.decode) !== null && _k !== void 0 ? _k : (payload, callback) => {\n          return callback(JSON.parse(payload));\n        };\n        break;\n      case VSN_2_0_0:\n        this.encode = (_l = options === null || options === void 0 ? void 0 : options.encode) !== null && _l !== void 0 ? _l : this.serializer.encode.bind(this.serializer);\n        this.decode = (_m = options === null || options === void 0 ? void 0 : options.decode) !== null && _m !== void 0 ? _m : this.serializer.decode.bind(this.serializer);\n        break;\n      default:\n        throw new Error(`Unsupported serializer version: ${this.vsn}`);\n    }\n    // Handle worker setup\n    if (this.worker) {\n      if (typeof window !== 'undefined' && !window.Worker) {\n        throw new Error('Web Worker is not supported');\n      }\n      this.workerUrl = options === null || options === void 0 ? void 0 : options.workerUrl;\n    }\n  }\n}","map":{"version":3,"names":["WebSocketFactory","CHANNEL_EVENTS","CONNECTION_STATE","DEFAULT_VERSION","DEFAULT_TIMEOUT","SOCKET_STATES","TRANSPORTS","DEFAULT_VSN","VSN_1_0_0","VSN_2_0_0","WS_CLOSE_NORMAL","Serializer","Timer","httpEndpointURL","RealtimeChannel","noop","CONNECTION_TIMEOUTS","HEARTBEAT_INTERVAL","RECONNECT_DELAY","HEARTBEAT_TIMEOUT_FALLBACK","RECONNECT_INTERVALS","DEFAULT_RECONNECT_FALLBACK","WORKER_SCRIPT","RealtimeClient","constructor","endPoint","options","accessTokenValue","apiKey","_manuallySetToken","channels","Array","httpEndpoint","headers","params","timeout","transport","heartbeatIntervalMs","heartbeatTimer","undefined","pendingHeartbeatRef","heartbeatCallback","ref","reconnectTimer","vsn","logger","conn","sendBuffer","serializer","stateChangeCallbacks","open","close","error","message","accessToken","_connectionState","_wasManualDisconnect","_authPromise","_heartbeatSentAt","_resolveFetch","customFetch","args","fetch","_a","apikey","Error","websocket","_initializeOptions","_setupReconnectionTimer","connect","isConnecting","isDisconnecting","isConnected","_setConnectionState","_setAuthSafely","endpointURL","createWebSocket","errorMessage","includes","_setupConnectionHandlers","_appendParams","Object","assign","disconnect","code","reason","fallbackTimer","setTimeout","onclose","clearTimeout","_teardownConnection","getChannels","removeChannel","channel","status","unsubscribe","length","removeAllChannels","values_1","Promise","all","map","log","kind","msg","data","connectionState","readyState","connecting","Connecting","Open","closing","Closing","Closed","topic","config","realtimeTopic","exists","find","c","chan","push","event","payload","callback","encode","result","send","setAuth","token","_performAuth","_isManualToken","sendHeartbeat","e","scheduleTimeout","Date","now","_makeRef","onHeartbeat","flushSendBuffer","forEach","newRef","toString","_leaveOpenTopic","dupChannel","_isJoined","_isJoining","_remove","filter","_onConnMessage","rawMessage","decode","latency","refString","trim","_isMember","_trigger","_triggerStateCallbacks","_clearTimer","timer","clearInterval","reset","_clearAllTimers","binaryType","onopen","_onConnOpen","onerror","_onConnError","onmessage","_onConnClose","_terminateWorker","teardown","authPromise","resolve","then","catch","worker","_startHeartbeat","workerRef","_startWorkerHeartbeat","setInterval","workerUrl","objectUrl","_workerObjectUrl","Worker","postMessage","interval","terminate","_triggerChanError","url","keys","prefix","match","query","URLSearchParams","result_url","blob","Blob","type","URL","createObjectURL","state","manual","tokenToSend","isManualToken","access_token","version","updateJoinPayload","joinedOnce","_push","_waitForAuthIfNeeded","context","reconnectAfterMs","_b","_c","_d","_e","_f","_g","logLevel","log_level","_h","tries","_j","JSON","stringify","_k","parse","_l","bind","_m","window"],"sources":["C:\\Users\\ResTIC16\\Desktop\\gest-o-financeira\\frontend\\node_modules\\@supabase\\realtime-js\\src\\RealtimeClient.ts"],"sourcesContent":["import WebSocketFactory, { WebSocketLike } from './lib/websocket-factory'\r\n\r\nimport {\r\n  CHANNEL_EVENTS,\r\n  CONNECTION_STATE,\r\n  DEFAULT_VERSION,\r\n  DEFAULT_TIMEOUT,\r\n  SOCKET_STATES,\r\n  TRANSPORTS,\r\n  DEFAULT_VSN,\r\n  VSN_1_0_0,\r\n  VSN_2_0_0,\r\n  WS_CLOSE_NORMAL,\r\n} from './lib/constants'\r\n\r\nimport Serializer from './lib/serializer'\r\nimport Timer from './lib/timer'\r\n\r\nimport { httpEndpointURL } from './lib/transformers'\r\nimport RealtimeChannel from './RealtimeChannel'\r\nimport type { RealtimeChannelOptions } from './RealtimeChannel'\r\n\r\ntype Fetch = typeof fetch\r\n\r\nexport type Channel = {\r\n  name: string\r\n  inserted_at: string\r\n  updated_at: string\r\n  id: number\r\n}\r\nexport type LogLevel = 'info' | 'warn' | 'error'\r\n\r\nexport type RealtimeMessage = {\r\n  topic: string\r\n  event: string\r\n  payload: any\r\n  ref: string\r\n  join_ref?: string\r\n}\r\n\r\nexport type RealtimeRemoveChannelResponse = 'ok' | 'timed out' | 'error'\r\nexport type HeartbeatStatus = 'sent' | 'ok' | 'error' | 'timeout' | 'disconnected'\r\n\r\nconst noop = () => {}\r\n\r\ntype RealtimeClientState = 'connecting' | 'connected' | 'disconnecting' | 'disconnected'\r\n\r\n// Connection-related constants\r\nconst CONNECTION_TIMEOUTS = {\r\n  HEARTBEAT_INTERVAL: 25000,\r\n  RECONNECT_DELAY: 10,\r\n  HEARTBEAT_TIMEOUT_FALLBACK: 100,\r\n} as const\r\n\r\nconst RECONNECT_INTERVALS = [1000, 2000, 5000, 10000] as const\r\nconst DEFAULT_RECONNECT_FALLBACK = 10000\r\n\r\n/**\r\n * Minimal WebSocket constructor interface that RealtimeClient can work with.\r\n * Supply a compatible implementation (native WebSocket, `ws`, etc) when running outside the browser.\r\n */\r\nexport interface WebSocketLikeConstructor {\r\n  new (address: string | URL, subprotocols?: string | string[] | undefined): WebSocketLike\r\n  // Allow additional properties that may exist on WebSocket constructors\r\n  [key: string]: any\r\n}\r\n\r\nexport interface WebSocketLikeError {\r\n  error: any\r\n  message: string\r\n  type: string\r\n}\r\n\r\nexport type RealtimeClientOptions = {\r\n  transport?: WebSocketLikeConstructor\r\n  timeout?: number\r\n  heartbeatIntervalMs?: number\r\n  heartbeatCallback?: (status: HeartbeatStatus, latency?: number) => void\r\n  vsn?: string\r\n  logger?: Function\r\n  encode?: Function\r\n  decode?: Function\r\n  reconnectAfterMs?: Function\r\n  headers?: { [key: string]: string }\r\n  params?: { [key: string]: any }\r\n  //Deprecated: Use it in favour of correct casing `logLevel`\r\n  log_level?: LogLevel\r\n  logLevel?: LogLevel\r\n  fetch?: Fetch\r\n  worker?: boolean\r\n  workerUrl?: string\r\n  accessToken?: () => Promise<string | null>\r\n}\r\n\r\nconst WORKER_SCRIPT = `\r\n  addEventListener(\"message\", (e) => {\r\n    if (e.data.event === \"start\") {\r\n      setInterval(() => postMessage({ event: \"keepAlive\" }), e.data.interval);\r\n    }\r\n  });`\r\n\r\nexport default class RealtimeClient {\r\n  accessTokenValue: string | null = null\r\n  apiKey: string | null = null\r\n  private _manuallySetToken: boolean = false\r\n  channels: RealtimeChannel[] = new Array()\r\n  endPoint: string = ''\r\n  httpEndpoint: string = ''\r\n  /** @deprecated headers cannot be set on websocket connections */\r\n  headers?: { [key: string]: string } = {}\r\n  params?: { [key: string]: string } = {}\r\n  timeout: number = DEFAULT_TIMEOUT\r\n  transport: WebSocketLikeConstructor | null = null\r\n  heartbeatIntervalMs: number = CONNECTION_TIMEOUTS.HEARTBEAT_INTERVAL\r\n  heartbeatTimer: ReturnType<typeof setInterval> | undefined = undefined\r\n  pendingHeartbeatRef: string | null = null\r\n  heartbeatCallback: (status: HeartbeatStatus, latency?: number) => void = noop\r\n  ref: number = 0\r\n  reconnectTimer: Timer | null = null\r\n  vsn: string = DEFAULT_VSN\r\n  logger: Function = noop\r\n  logLevel?: LogLevel\r\n  encode!: Function\r\n  decode!: Function\r\n  reconnectAfterMs!: Function\r\n  conn: WebSocketLike | null = null\r\n  sendBuffer: Function[] = []\r\n  serializer: Serializer = new Serializer()\r\n  stateChangeCallbacks: {\r\n    open: Function[]\r\n    close: Function[]\r\n    error: Function[]\r\n    message: Function[]\r\n  } = {\r\n    open: [],\r\n    close: [],\r\n    error: [],\r\n    message: [],\r\n  }\r\n  fetch: Fetch\r\n  accessToken: (() => Promise<string | null>) | null = null\r\n  worker?: boolean\r\n  workerUrl?: string\r\n  workerRef?: Worker\r\n  private _connectionState: RealtimeClientState = 'disconnected'\r\n  private _wasManualDisconnect: boolean = false\r\n  private _authPromise: Promise<void> | null = null\r\n  private _heartbeatSentAt: number | null = null\r\n\r\n  /**\r\n   * Initializes the Socket.\r\n   *\r\n   * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\r\n   * @param httpEndpoint The string HTTP endpoint, ie, \"https://example.com\", \"/\" (inherited host & protocol)\r\n   * @param options.transport The Websocket Transport, for example WebSocket. This can be a custom implementation\r\n   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\r\n   * @param options.params The optional params to pass when connecting.\r\n   * @param options.headers Deprecated: headers cannot be set on websocket connections and this option will be removed in the future.\r\n   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\r\n   * @param options.heartbeatCallback The optional function to handle heartbeat status and latency.\r\n   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\r\n   * @param options.logLevel Sets the log level for Realtime\r\n   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\r\n   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\r\n   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\r\n   * @param options.worker Use Web Worker to set a side flow. Defaults to false.\r\n   * @param options.workerUrl The URL of the worker script. Defaults to https://realtime.supabase.com/worker.js that includes a heartbeat event call to keep the connection alive.\r\n   * @param options.vsn The protocol version to use when connecting. Supported versions are \"1.0.0\" and \"2.0.0\". Defaults to \"2.0.0\".\r\n   * @example\r\n   * ```ts\r\n   * import RealtimeClient from '@supabase/realtime-js'\r\n   *\r\n   * const client = new RealtimeClient('https://xyzcompany.supabase.co/realtime/v1', {\r\n   *   params: { apikey: 'public-anon-key' },\r\n   * })\r\n   * client.connect()\r\n   * ```\r\n   */\r\n  constructor(endPoint: string, options?: RealtimeClientOptions) {\r\n    // Validate required parameters\r\n    if (!options?.params?.apikey) {\r\n      throw new Error('API key is required to connect to Realtime')\r\n    }\r\n    this.apiKey = options.params.apikey\r\n\r\n    // Initialize endpoint URLs\r\n    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`\r\n    this.httpEndpoint = httpEndpointURL(endPoint)\r\n\r\n    this._initializeOptions(options)\r\n    this._setupReconnectionTimer()\r\n    this.fetch = this._resolveFetch(options?.fetch)\r\n  }\r\n\r\n  /**\r\n   * Connects the socket, unless already connected.\r\n   */\r\n  connect(): void {\r\n    // Skip if already connecting, disconnecting, or connected\r\n    if (\r\n      this.isConnecting() ||\r\n      this.isDisconnecting() ||\r\n      (this.conn !== null && this.isConnected())\r\n    ) {\r\n      return\r\n    }\r\n\r\n    this._setConnectionState('connecting')\r\n\r\n    // Trigger auth if needed and not already in progress\r\n    // This ensures auth is called for standalone RealtimeClient usage\r\n    // while avoiding race conditions with SupabaseClient's immediate setAuth call\r\n    if (this.accessToken && !this._authPromise) {\r\n      this._setAuthSafely('connect')\r\n    }\r\n\r\n    // Establish WebSocket connection\r\n    if (this.transport) {\r\n      // Use custom transport if provided\r\n      this.conn = new this.transport(this.endpointURL()) as WebSocketLike\r\n    } else {\r\n      // Try to use native WebSocket\r\n      try {\r\n        this.conn = WebSocketFactory.createWebSocket(this.endpointURL())\r\n      } catch (error) {\r\n        this._setConnectionState('disconnected')\r\n        const errorMessage = (error as Error).message\r\n\r\n        // Provide helpful error message based on environment\r\n        if (errorMessage.includes('Node.js')) {\r\n          throw new Error(\r\n            `${errorMessage}\\n\\n` +\r\n              'To use Realtime in Node.js, you need to provide a WebSocket implementation:\\n\\n' +\r\n              'Option 1: Use Node.js 22+ which has native WebSocket support\\n' +\r\n              'Option 2: Install and provide the \"ws\" package:\\n\\n' +\r\n              '  npm install ws\\n\\n' +\r\n              '  import ws from \"ws\"\\n' +\r\n              '  const client = new RealtimeClient(url, {\\n' +\r\n              '    ...options,\\n' +\r\n              '    transport: ws\\n' +\r\n              '  })'\r\n          )\r\n        }\r\n        throw new Error(`WebSocket not available: ${errorMessage}`)\r\n      }\r\n    }\r\n    this._setupConnectionHandlers()\r\n  }\r\n\r\n  /**\r\n   * Returns the URL of the websocket.\r\n   * @returns string The URL of the websocket.\r\n   */\r\n  endpointURL(): string {\r\n    return this._appendParams(this.endPoint, Object.assign({}, this.params, { vsn: this.vsn }))\r\n  }\r\n\r\n  /**\r\n   * Disconnects the socket.\r\n   *\r\n   * @param code A numeric status code to send on disconnect.\r\n   * @param reason A custom reason for the disconnect.\r\n   */\r\n  disconnect(code?: number, reason?: string): void {\r\n    if (this.isDisconnecting()) {\r\n      return\r\n    }\r\n\r\n    this._setConnectionState('disconnecting', true)\r\n\r\n    if (this.conn) {\r\n      // Setup fallback timer to prevent hanging in disconnecting state\r\n      const fallbackTimer = setTimeout(() => {\r\n        this._setConnectionState('disconnected')\r\n      }, 100)\r\n\r\n      this.conn.onclose = () => {\r\n        clearTimeout(fallbackTimer)\r\n        this._setConnectionState('disconnected')\r\n      }\r\n\r\n      // Close the WebSocket connection if close method exists\r\n      if (typeof this.conn.close === 'function') {\r\n        if (code) {\r\n          this.conn.close(code, reason ?? '')\r\n        } else {\r\n          this.conn.close()\r\n        }\r\n      }\r\n\r\n      this._teardownConnection()\r\n    } else {\r\n      this._setConnectionState('disconnected')\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns all created channels\r\n   */\r\n  getChannels(): RealtimeChannel[] {\r\n    return this.channels\r\n  }\r\n\r\n  /**\r\n   * Unsubscribes and removes a single channel\r\n   * @param channel A RealtimeChannel instance\r\n   */\r\n  async removeChannel(channel: RealtimeChannel): Promise<RealtimeRemoveChannelResponse> {\r\n    const status = await channel.unsubscribe()\r\n\r\n    if (this.channels.length === 0) {\r\n      this.disconnect()\r\n    }\r\n\r\n    return status\r\n  }\r\n\r\n  /**\r\n   * Unsubscribes and removes all channels\r\n   */\r\n  async removeAllChannels(): Promise<RealtimeRemoveChannelResponse[]> {\r\n    const values_1 = await Promise.all(this.channels.map((channel) => channel.unsubscribe()))\r\n    this.channels = []\r\n    this.disconnect()\r\n    return values_1\r\n  }\r\n\r\n  /**\r\n   * Logs the message.\r\n   *\r\n   * For customized logging, `this.logger` can be overridden.\r\n   */\r\n  log(kind: string, msg: string, data?: any) {\r\n    this.logger(kind, msg, data)\r\n  }\r\n\r\n  /**\r\n   * Returns the current state of the socket.\r\n   */\r\n  connectionState(): CONNECTION_STATE {\r\n    switch (this.conn && this.conn.readyState) {\r\n      case SOCKET_STATES.connecting:\r\n        return CONNECTION_STATE.Connecting\r\n      case SOCKET_STATES.open:\r\n        return CONNECTION_STATE.Open\r\n      case SOCKET_STATES.closing:\r\n        return CONNECTION_STATE.Closing\r\n      default:\r\n        return CONNECTION_STATE.Closed\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns `true` is the connection is open.\r\n   */\r\n  isConnected(): boolean {\r\n    return this.connectionState() === CONNECTION_STATE.Open\r\n  }\r\n\r\n  /**\r\n   * Returns `true` if the connection is currently connecting.\r\n   */\r\n  isConnecting(): boolean {\r\n    return this._connectionState === 'connecting'\r\n  }\r\n\r\n  /**\r\n   * Returns `true` if the connection is currently disconnecting.\r\n   */\r\n  isDisconnecting(): boolean {\r\n    return this._connectionState === 'disconnecting'\r\n  }\r\n\r\n  /**\r\n   * Creates (or reuses) a {@link RealtimeChannel} for the provided topic.\r\n   *\r\n   * Topics are automatically prefixed with `realtime:` to match the Realtime service.\r\n   * If a channel with the same topic already exists it will be returned instead of creating\r\n   * a duplicate connection.\r\n   */\r\n  channel(topic: string, params: RealtimeChannelOptions = { config: {} }): RealtimeChannel {\r\n    const realtimeTopic = `realtime:${topic}`\r\n    const exists = this.getChannels().find((c: RealtimeChannel) => c.topic === realtimeTopic)\r\n\r\n    if (!exists) {\r\n      const chan = new RealtimeChannel(`realtime:${topic}`, params, this)\r\n      this.channels.push(chan)\r\n\r\n      return chan\r\n    } else {\r\n      return exists\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Push out a message if the socket is connected.\r\n   *\r\n   * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\r\n   */\r\n  push(data: RealtimeMessage): void {\r\n    const { topic, event, payload, ref } = data\r\n    const callback = () => {\r\n      this.encode(data, (result: any) => {\r\n        this.conn?.send(result)\r\n      })\r\n    }\r\n    this.log('push', `${topic} ${event} (${ref})`, payload)\r\n    if (this.isConnected()) {\r\n      callback()\r\n    } else {\r\n      this.sendBuffer.push(callback)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\r\n   *\r\n   * If param is null it will use the `accessToken` callback function or the token set on the client.\r\n   *\r\n   * On callback used, it will set the value of the token internal to the client.\r\n   *\r\n   * When a token is explicitly provided, it will be preserved across channel operations\r\n   * (including removeChannel and resubscribe). The `accessToken` callback will not be\r\n   * invoked until `setAuth()` is called without arguments.\r\n   *\r\n   * @param token A JWT string to override the token set on the client.\r\n   *\r\n   * @example\r\n   * // Use a manual token (preserved across resubscribes, ignores accessToken callback)\r\n   * client.realtime.setAuth('my-custom-jwt')\r\n   *\r\n   * // Switch back to using the accessToken callback\r\n   * client.realtime.setAuth()\r\n   */\r\n  async setAuth(token: string | null = null): Promise<void> {\r\n    this._authPromise = this._performAuth(token)\r\n    try {\r\n      await this._authPromise\r\n    } finally {\r\n      this._authPromise = null\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns true if the current access token was explicitly set via setAuth(token),\r\n   * false if it was obtained via the accessToken callback.\r\n   * @internal\r\n   */\r\n  _isManualToken(): boolean {\r\n    return this._manuallySetToken\r\n  }\r\n\r\n  /**\r\n   * Sends a heartbeat message if the socket is connected.\r\n   */\r\n  async sendHeartbeat() {\r\n    if (!this.isConnected()) {\r\n      try {\r\n        this.heartbeatCallback('disconnected')\r\n      } catch (e) {\r\n        this.log('error', 'error in heartbeat callback', e)\r\n      }\r\n      return\r\n    }\r\n\r\n    // Handle heartbeat timeout and force reconnection if needed\r\n    if (this.pendingHeartbeatRef) {\r\n      this.pendingHeartbeatRef = null\r\n      this._heartbeatSentAt = null\r\n      this.log('transport', 'heartbeat timeout. Attempting to re-establish connection')\r\n      try {\r\n        this.heartbeatCallback('timeout')\r\n      } catch (e) {\r\n        this.log('error', 'error in heartbeat callback', e)\r\n      }\r\n\r\n      // Force reconnection after heartbeat timeout\r\n      this._wasManualDisconnect = false\r\n      this.conn?.close(WS_CLOSE_NORMAL, 'heartbeat timeout')\r\n\r\n      setTimeout(() => {\r\n        if (!this.isConnected()) {\r\n          this.reconnectTimer?.scheduleTimeout()\r\n        }\r\n      }, CONNECTION_TIMEOUTS.HEARTBEAT_TIMEOUT_FALLBACK)\r\n      return\r\n    }\r\n\r\n    // Send heartbeat message to server\r\n    this._heartbeatSentAt = Date.now()\r\n    this.pendingHeartbeatRef = this._makeRef()\r\n    this.push({\r\n      topic: 'phoenix',\r\n      event: 'heartbeat',\r\n      payload: {},\r\n      ref: this.pendingHeartbeatRef,\r\n    })\r\n    try {\r\n      this.heartbeatCallback('sent')\r\n    } catch (e) {\r\n      this.log('error', 'error in heartbeat callback', e)\r\n    }\r\n\r\n    this._setAuthSafely('heartbeat')\r\n  }\r\n\r\n  /**\r\n   * Sets a callback that receives lifecycle events for internal heartbeat messages.\r\n   * Useful for instrumenting connection health (e.g. sent/ok/timeout/disconnected).\r\n   */\r\n  onHeartbeat(callback: (status: HeartbeatStatus, latency?: number) => void): void {\r\n    this.heartbeatCallback = callback\r\n  }\r\n  /**\r\n   * Flushes send buffer\r\n   */\r\n  flushSendBuffer() {\r\n    if (this.isConnected() && this.sendBuffer.length > 0) {\r\n      this.sendBuffer.forEach((callback) => callback())\r\n      this.sendBuffer = []\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Use either custom fetch, if provided, or default fetch to make HTTP requests\r\n   *\r\n   * @internal\r\n   */\r\n  _resolveFetch = (customFetch?: Fetch): Fetch => {\r\n    if (customFetch) {\r\n      return (...args) => customFetch(...args)\r\n    }\r\n    return (...args) => fetch(...args)\r\n  }\r\n\r\n  /**\r\n   * Return the next message ref, accounting for overflows\r\n   *\r\n   * @internal\r\n   */\r\n  _makeRef(): string {\r\n    let newRef = this.ref + 1\r\n    if (newRef === this.ref) {\r\n      this.ref = 0\r\n    } else {\r\n      this.ref = newRef\r\n    }\r\n\r\n    return this.ref.toString()\r\n  }\r\n\r\n  /**\r\n   * Unsubscribe from channels with the specified topic.\r\n   *\r\n   * @internal\r\n   */\r\n  _leaveOpenTopic(topic: string): void {\r\n    let dupChannel = this.channels.find(\r\n      (c) => c.topic === topic && (c._isJoined() || c._isJoining())\r\n    )\r\n    if (dupChannel) {\r\n      this.log('transport', `leaving duplicate topic \"${topic}\"`)\r\n      dupChannel.unsubscribe()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes a subscription from the socket.\r\n   *\r\n   * @param channel An open subscription.\r\n   *\r\n   * @internal\r\n   */\r\n  _remove(channel: RealtimeChannel) {\r\n    this.channels = this.channels.filter((c) => c.topic !== channel.topic)\r\n  }\r\n\r\n  /** @internal */\r\n  private _onConnMessage(rawMessage: { data: any }) {\r\n    this.decode(rawMessage.data, (msg: RealtimeMessage) => {\r\n      // Handle heartbeat responses\r\n      if (\r\n        msg.topic === 'phoenix' &&\r\n        msg.event === 'phx_reply' &&\r\n        msg.ref &&\r\n        msg.ref === this.pendingHeartbeatRef\r\n      ) {\r\n        const latency = this._heartbeatSentAt ? Date.now() - this._heartbeatSentAt : undefined\r\n        try {\r\n          this.heartbeatCallback(msg.payload.status === 'ok' ? 'ok' : 'error', latency)\r\n        } catch (e) {\r\n          this.log('error', 'error in heartbeat callback', e)\r\n        }\r\n        this._heartbeatSentAt = null\r\n        this.pendingHeartbeatRef = null\r\n      }\r\n\r\n      // Log incoming message\r\n      const { topic, event, payload, ref } = msg\r\n      const refString = ref ? `(${ref})` : ''\r\n      const status = payload.status || ''\r\n      this.log('receive', `${status} ${topic} ${event} ${refString}`.trim(), payload)\r\n\r\n      // Route message to appropriate channels\r\n      this.channels\r\n        .filter((channel: RealtimeChannel) => channel._isMember(topic))\r\n        .forEach((channel: RealtimeChannel) => channel._trigger(event, payload, ref))\r\n\r\n      this._triggerStateCallbacks('message', msg)\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Clear specific timer\r\n   * @internal\r\n   */\r\n  private _clearTimer(timer: 'heartbeat' | 'reconnect'): void {\r\n    if (timer === 'heartbeat' && this.heartbeatTimer) {\r\n      clearInterval(this.heartbeatTimer)\r\n      this.heartbeatTimer = undefined\r\n    } else if (timer === 'reconnect') {\r\n      this.reconnectTimer?.reset()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clear all timers\r\n   * @internal\r\n   */\r\n  private _clearAllTimers(): void {\r\n    this._clearTimer('heartbeat')\r\n    this._clearTimer('reconnect')\r\n  }\r\n\r\n  /**\r\n   * Setup connection handlers for WebSocket events\r\n   * @internal\r\n   */\r\n  private _setupConnectionHandlers(): void {\r\n    if (!this.conn) return\r\n\r\n    // Set binary type if supported (browsers and most WebSocket implementations)\r\n    if ('binaryType' in this.conn) {\r\n      ;(this.conn as any).binaryType = 'arraybuffer'\r\n    }\r\n\r\n    this.conn.onopen = () => this._onConnOpen()\r\n    this.conn.onerror = (error: Event) => this._onConnError(error)\r\n    this.conn.onmessage = (event: any) => this._onConnMessage(event)\r\n    this.conn.onclose = (event: any) => this._onConnClose(event)\r\n\r\n    if (this.conn.readyState === SOCKET_STATES.open) {\r\n      this._onConnOpen()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Teardown connection and cleanup resources\r\n   * @internal\r\n   */\r\n  private _teardownConnection(): void {\r\n    if (this.conn) {\r\n      if (\r\n        this.conn.readyState === SOCKET_STATES.open ||\r\n        this.conn.readyState === SOCKET_STATES.connecting\r\n      ) {\r\n        try {\r\n          this.conn.close()\r\n        } catch (e) {\r\n          this.log('error', 'Error closing connection', e)\r\n        }\r\n      }\r\n\r\n      this.conn.onopen = null\r\n      this.conn.onerror = null\r\n      this.conn.onmessage = null\r\n      this.conn.onclose = null\r\n      this.conn = null\r\n    }\r\n    this._clearAllTimers()\r\n    this._terminateWorker()\r\n    this.channels.forEach((channel) => channel.teardown())\r\n  }\r\n\r\n  /** @internal */\r\n  private _onConnOpen() {\r\n    this._setConnectionState('connected')\r\n    this.log('transport', `connected to ${this.endpointURL()}`)\r\n\r\n    // Wait for any pending auth operations before flushing send buffer\r\n    // This ensures channel join messages include the correct access token\r\n    const authPromise =\r\n      this._authPromise ||\r\n      (this.accessToken && !this.accessTokenValue ? this.setAuth() : Promise.resolve())\r\n\r\n    authPromise\r\n      .then(() => {\r\n        this.flushSendBuffer()\r\n      })\r\n      .catch((e) => {\r\n        this.log('error', 'error waiting for auth on connect', e)\r\n        // Proceed anyway to avoid hanging connections\r\n        this.flushSendBuffer()\r\n      })\r\n\r\n    this._clearTimer('reconnect')\r\n\r\n    if (!this.worker) {\r\n      this._startHeartbeat()\r\n    } else {\r\n      if (!this.workerRef) {\r\n        this._startWorkerHeartbeat()\r\n      }\r\n    }\r\n\r\n    this._triggerStateCallbacks('open')\r\n  }\r\n  /** @internal */\r\n  private _startHeartbeat() {\r\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer)\r\n    this.heartbeatTimer = setInterval(() => this.sendHeartbeat(), this.heartbeatIntervalMs)\r\n  }\r\n\r\n  /** @internal */\r\n  private _startWorkerHeartbeat() {\r\n    if (this.workerUrl) {\r\n      this.log('worker', `starting worker for from ${this.workerUrl}`)\r\n    } else {\r\n      this.log('worker', `starting default worker`)\r\n    }\r\n    const objectUrl = this._workerObjectUrl(this.workerUrl!)\r\n    this.workerRef = new Worker(objectUrl)\r\n    this.workerRef.onerror = (error) => {\r\n      this.log('worker', 'worker error', (error as ErrorEvent).message)\r\n      this._terminateWorker()\r\n    }\r\n    this.workerRef.onmessage = (event) => {\r\n      if (event.data.event === 'keepAlive') {\r\n        this.sendHeartbeat()\r\n      }\r\n    }\r\n    this.workerRef.postMessage({\r\n      event: 'start',\r\n      interval: this.heartbeatIntervalMs,\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Terminate the Web Worker and clear the reference\r\n   * @internal\r\n   */\r\n  private _terminateWorker(): void {\r\n    if (this.workerRef) {\r\n      this.log('worker', 'terminating worker')\r\n      this.workerRef.terminate()\r\n      this.workerRef = undefined\r\n    }\r\n  }\r\n  /** @internal */\r\n  private _onConnClose(event: any) {\r\n    this._setConnectionState('disconnected')\r\n    this.log('transport', 'close', event)\r\n    this._triggerChanError()\r\n    this._clearTimer('heartbeat')\r\n\r\n    // Only schedule reconnection if it wasn't a manual disconnect\r\n    if (!this._wasManualDisconnect) {\r\n      this.reconnectTimer?.scheduleTimeout()\r\n    }\r\n\r\n    this._triggerStateCallbacks('close', event)\r\n  }\r\n\r\n  /** @internal */\r\n  private _onConnError(error: Event) {\r\n    this._setConnectionState('disconnected')\r\n    this.log('transport', `${error}`)\r\n    this._triggerChanError()\r\n    this._triggerStateCallbacks('error', error)\r\n    try {\r\n      this.heartbeatCallback('error')\r\n    } catch (e) {\r\n      this.log('error', 'error in heartbeat callback', e)\r\n    }\r\n  }\r\n\r\n  /** @internal */\r\n  private _triggerChanError() {\r\n    this.channels.forEach((channel: RealtimeChannel) => channel._trigger(CHANNEL_EVENTS.error))\r\n  }\r\n\r\n  /** @internal */\r\n  private _appendParams(url: string, params: { [key: string]: string }): string {\r\n    if (Object.keys(params).length === 0) {\r\n      return url\r\n    }\r\n    const prefix = url.match(/\\?/) ? '&' : '?'\r\n    const query = new URLSearchParams(params)\r\n    return `${url}${prefix}${query}`\r\n  }\r\n\r\n  private _workerObjectUrl(url: string | undefined): string {\r\n    let result_url: string\r\n    if (url) {\r\n      result_url = url\r\n    } else {\r\n      const blob = new Blob([WORKER_SCRIPT], { type: 'application/javascript' })\r\n      result_url = URL.createObjectURL(blob)\r\n    }\r\n    return result_url\r\n  }\r\n\r\n  /**\r\n   * Set connection state with proper state management\r\n   * @internal\r\n   */\r\n  private _setConnectionState(state: RealtimeClientState, manual = false): void {\r\n    this._connectionState = state\r\n\r\n    if (state === 'connecting') {\r\n      this._wasManualDisconnect = false\r\n    } else if (state === 'disconnecting') {\r\n      this._wasManualDisconnect = manual\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Perform the actual auth operation\r\n   * @internal\r\n   */\r\n  private async _performAuth(token: string | null = null): Promise<void> {\r\n    let tokenToSend: string | null\r\n    let isManualToken = false\r\n\r\n    if (token) {\r\n      tokenToSend = token\r\n      // Track if this is a manually-provided token\r\n      isManualToken = true\r\n    } else if (this.accessToken) {\r\n      // Call the accessToken callback to get fresh token\r\n      try {\r\n        tokenToSend = await this.accessToken()\r\n      } catch (e) {\r\n        this.log('error', 'Error fetching access token from callback', e)\r\n        // Fall back to cached value if callback fails\r\n        tokenToSend = this.accessTokenValue\r\n      }\r\n    } else {\r\n      tokenToSend = this.accessTokenValue\r\n    }\r\n\r\n    // Track whether this token was manually set or fetched via callback\r\n    if (isManualToken) {\r\n      this._manuallySetToken = true\r\n    } else if (this.accessToken) {\r\n      // If we used the callback, clear the manual flag\r\n      this._manuallySetToken = false\r\n    }\r\n\r\n    if (this.accessTokenValue != tokenToSend) {\r\n      this.accessTokenValue = tokenToSend\r\n      this.channels.forEach((channel) => {\r\n        const payload = {\r\n          access_token: tokenToSend,\r\n          version: DEFAULT_VERSION,\r\n        }\r\n\r\n        tokenToSend && channel.updateJoinPayload(payload)\r\n\r\n        if (channel.joinedOnce && channel._isJoined()) {\r\n          channel._push(CHANNEL_EVENTS.access_token, {\r\n            access_token: tokenToSend,\r\n          })\r\n        }\r\n      })\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Wait for any in-flight auth operations to complete\r\n   * @internal\r\n   */\r\n  private async _waitForAuthIfNeeded(): Promise<void> {\r\n    if (this._authPromise) {\r\n      await this._authPromise\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Safely call setAuth with standardized error handling\r\n   * @internal\r\n   */\r\n  private _setAuthSafely(context = 'general'): void {\r\n    // Only refresh auth if using callback-based tokens\r\n    if (!this._isManualToken()) {\r\n      this.setAuth().catch((e) => {\r\n        this.log('error', `Error setting auth in ${context}`, e)\r\n      })\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Trigger state change callbacks with proper error handling\r\n   * @internal\r\n   */\r\n  private _triggerStateCallbacks(event: keyof typeof this.stateChangeCallbacks, data?: any): void {\r\n    try {\r\n      this.stateChangeCallbacks[event].forEach((callback) => {\r\n        try {\r\n          callback(data)\r\n        } catch (e) {\r\n          this.log('error', `error in ${event} callback`, e)\r\n        }\r\n      })\r\n    } catch (e) {\r\n      this.log('error', `error triggering ${event} callbacks`, e)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Setup reconnection timer with proper configuration\r\n   * @internal\r\n   */\r\n  private _setupReconnectionTimer(): void {\r\n    this.reconnectTimer = new Timer(async () => {\r\n      setTimeout(async () => {\r\n        await this._waitForAuthIfNeeded()\r\n        if (!this.isConnected()) {\r\n          this.connect()\r\n        }\r\n      }, CONNECTION_TIMEOUTS.RECONNECT_DELAY)\r\n    }, this.reconnectAfterMs)\r\n  }\r\n\r\n  /**\r\n   * Initialize client options with defaults\r\n   * @internal\r\n   */\r\n  private _initializeOptions(options?: RealtimeClientOptions): void {\r\n    // Set defaults\r\n    this.transport = options?.transport ?? null\r\n    this.timeout = options?.timeout ?? DEFAULT_TIMEOUT\r\n    this.heartbeatIntervalMs =\r\n      options?.heartbeatIntervalMs ?? CONNECTION_TIMEOUTS.HEARTBEAT_INTERVAL\r\n    this.worker = options?.worker ?? false\r\n    this.accessToken = options?.accessToken ?? null\r\n    this.heartbeatCallback = options?.heartbeatCallback ?? noop\r\n    this.vsn = options?.vsn ?? DEFAULT_VSN\r\n\r\n    // Handle special cases\r\n    if (options?.params) this.params = options.params\r\n    if (options?.logger) this.logger = options.logger\r\n    if (options?.logLevel || options?.log_level) {\r\n      this.logLevel = options.logLevel || options.log_level\r\n      this.params = { ...this.params, log_level: this.logLevel as string }\r\n    }\r\n\r\n    // Set up functions with defaults\r\n    this.reconnectAfterMs =\r\n      options?.reconnectAfterMs ??\r\n      ((tries: number) => {\r\n        return RECONNECT_INTERVALS[tries - 1] || DEFAULT_RECONNECT_FALLBACK\r\n      })\r\n\r\n    switch (this.vsn) {\r\n      case VSN_1_0_0:\r\n        this.encode =\r\n          options?.encode ??\r\n          ((payload: JSON, callback: Function) => {\r\n            return callback(JSON.stringify(payload))\r\n          })\r\n\r\n        this.decode =\r\n          options?.decode ??\r\n          ((payload: string, callback: Function) => {\r\n            return callback(JSON.parse(payload))\r\n          })\r\n        break\r\n      case VSN_2_0_0:\r\n        this.encode = options?.encode ?? this.serializer.encode.bind(this.serializer)\r\n        this.decode = options?.decode ?? this.serializer.decode.bind(this.serializer)\r\n        break\r\n      default:\r\n        throw new Error(`Unsupported serializer version: ${this.vsn}`)\r\n    }\r\n\r\n    // Handle worker setup\r\n    if (this.worker) {\r\n      if (typeof window !== 'undefined' && !window.Worker) {\r\n        throw new Error('Web Worker is not supported')\r\n      }\r\n      this.workerUrl = options?.workerUrl\r\n    }\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}