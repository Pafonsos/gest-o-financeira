{"ast":null,"code":"import { CHANNEL_EVENTS, CHANNEL_STATES, MAX_PUSH_BUFFER_SIZE } from './lib/constants';\nimport Push from './lib/push';\nimport Timer from './lib/timer';\nimport RealtimePresence from './RealtimePresence';\nimport * as Transformers from './lib/transformers';\nimport { httpEndpointURL } from './lib/transformers';\nexport var REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;\n(function (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT) {\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"ALL\"] = \"*\";\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"INSERT\"] = \"INSERT\";\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"UPDATE\"] = \"UPDATE\";\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"DELETE\"] = \"DELETE\";\n})(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT || (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = {}));\nexport var REALTIME_LISTEN_TYPES;\n(function (REALTIME_LISTEN_TYPES) {\n  REALTIME_LISTEN_TYPES[\"BROADCAST\"] = \"broadcast\";\n  REALTIME_LISTEN_TYPES[\"PRESENCE\"] = \"presence\";\n  REALTIME_LISTEN_TYPES[\"POSTGRES_CHANGES\"] = \"postgres_changes\";\n  REALTIME_LISTEN_TYPES[\"SYSTEM\"] = \"system\";\n})(REALTIME_LISTEN_TYPES || (REALTIME_LISTEN_TYPES = {}));\nexport var REALTIME_SUBSCRIBE_STATES;\n(function (REALTIME_SUBSCRIBE_STATES) {\n  REALTIME_SUBSCRIBE_STATES[\"SUBSCRIBED\"] = \"SUBSCRIBED\";\n  REALTIME_SUBSCRIBE_STATES[\"TIMED_OUT\"] = \"TIMED_OUT\";\n  REALTIME_SUBSCRIBE_STATES[\"CLOSED\"] = \"CLOSED\";\n  REALTIME_SUBSCRIBE_STATES[\"CHANNEL_ERROR\"] = \"CHANNEL_ERROR\";\n})(REALTIME_SUBSCRIBE_STATES || (REALTIME_SUBSCRIBE_STATES = {}));\nexport const REALTIME_CHANNEL_STATES = CHANNEL_STATES;\n/** A channel is the basic building block of Realtime\r\n * and narrows the scope of data flow to subscribed clients.\r\n * You can think of a channel as a chatroom where participants are able to see who's online\r\n * and send and receive messages.\r\n */\nexport default class RealtimeChannel {\n  /**\r\n   * Creates a channel that can broadcast messages, sync presence, and listen to Postgres changes.\r\n   *\r\n   * The topic determines which realtime stream you are subscribing to. Config options let you\r\n   * enable acknowledgement for broadcasts, presence tracking, or private channels.\r\n   *\r\n   * @example\r\n   * ```ts\r\n   * import RealtimeClient from '@supabase/realtime-js'\r\n   *\r\n   * const client = new RealtimeClient('https://xyzcompany.supabase.co/realtime/v1', {\r\n   *   params: { apikey: 'public-anon-key' },\r\n   * })\r\n   * const channel = new RealtimeChannel('realtime:public:messages', { config: {} }, client)\r\n   * ```\r\n   */\n  constructor(/** Topic name can be any string. */\n  topic, params = {\n    config: {}\n  }, socket) {\n    var _a, _b;\n    this.topic = topic;\n    this.params = params;\n    this.socket = socket;\n    this.bindings = {};\n    this.state = CHANNEL_STATES.closed;\n    this.joinedOnce = false;\n    this.pushBuffer = [];\n    this.subTopic = topic.replace(/^realtime:/i, '');\n    this.params.config = Object.assign({\n      broadcast: {\n        ack: false,\n        self: false\n      },\n      presence: {\n        key: '',\n        enabled: false\n      },\n      private: false\n    }, params.config);\n    this.timeout = this.socket.timeout;\n    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n    this.rejoinTimer = new Timer(() => this._rejoinUntilConnected(), this.socket.reconnectAfterMs);\n    this.joinPush.receive('ok', () => {\n      this.state = CHANNEL_STATES.joined;\n      this.rejoinTimer.reset();\n      this.pushBuffer.forEach(pushEvent => pushEvent.send());\n      this.pushBuffer = [];\n    });\n    this._onClose(() => {\n      this.rejoinTimer.reset();\n      this.socket.log('channel', `close ${this.topic} ${this._joinRef()}`);\n      this.state = CHANNEL_STATES.closed;\n      this.socket._remove(this);\n    });\n    this._onError(reason => {\n      if (this._isLeaving() || this._isClosed()) {\n        return;\n      }\n      this.socket.log('channel', `error ${this.topic}`, reason);\n      this.state = CHANNEL_STATES.errored;\n      this.rejoinTimer.scheduleTimeout();\n    });\n    this.joinPush.receive('timeout', () => {\n      if (!this._isJoining()) {\n        return;\n      }\n      this.socket.log('channel', `timeout ${this.topic}`, this.joinPush.timeout);\n      this.state = CHANNEL_STATES.errored;\n      this.rejoinTimer.scheduleTimeout();\n    });\n    this.joinPush.receive('error', reason => {\n      if (this._isLeaving() || this._isClosed()) {\n        return;\n      }\n      this.socket.log('channel', `error ${this.topic}`, reason);\n      this.state = CHANNEL_STATES.errored;\n      this.rejoinTimer.scheduleTimeout();\n    });\n    this._on(CHANNEL_EVENTS.reply, {}, (payload, ref) => {\n      this._trigger(this._replyEventName(ref), payload);\n    });\n    this.presence = new RealtimePresence(this);\n    this.broadcastEndpointURL = httpEndpointURL(this.socket.endPoint);\n    this.private = this.params.config.private || false;\n    if (!this.private && ((_b = (_a = this.params.config) === null || _a === void 0 ? void 0 : _a.broadcast) === null || _b === void 0 ? void 0 : _b.replay)) {\n      throw `tried to use replay on public channel '${this.topic}'. It must be a private channel.`;\n    }\n  }\n  /** Subscribe registers your client with the server */\n  subscribe(callback, timeout = this.timeout) {\n    var _a, _b, _c;\n    if (!this.socket.isConnected()) {\n      this.socket.connect();\n    }\n    if (this.state == CHANNEL_STATES.closed) {\n      const {\n        config: {\n          broadcast,\n          presence,\n          private: isPrivate\n        }\n      } = this.params;\n      const postgres_changes = (_b = (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.map(r => r.filter)) !== null && _b !== void 0 ? _b : [];\n      const presence_enabled = !!this.bindings[REALTIME_LISTEN_TYPES.PRESENCE] && this.bindings[REALTIME_LISTEN_TYPES.PRESENCE].length > 0 || ((_c = this.params.config.presence) === null || _c === void 0 ? void 0 : _c.enabled) === true;\n      const accessTokenPayload = {};\n      const config = {\n        broadcast,\n        presence: Object.assign(Object.assign({}, presence), {\n          enabled: presence_enabled\n        }),\n        postgres_changes,\n        private: isPrivate\n      };\n      if (this.socket.accessTokenValue) {\n        accessTokenPayload.access_token = this.socket.accessTokenValue;\n      }\n      this._onError(e => callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, e));\n      this._onClose(() => callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CLOSED));\n      this.updateJoinPayload(Object.assign({\n        config\n      }, accessTokenPayload));\n      this.joinedOnce = true;\n      this._rejoin(timeout);\n      this.joinPush.receive('ok', async ({\n        postgres_changes\n      }) => {\n        var _a;\n        // Only refresh auth if using callback-based tokens\n        if (!this.socket._isManualToken()) {\n          this.socket.setAuth();\n        }\n        if (postgres_changes === undefined) {\n          callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);\n          return;\n        } else {\n          const clientPostgresBindings = this.bindings.postgres_changes;\n          const bindingsLen = (_a = clientPostgresBindings === null || clientPostgresBindings === void 0 ? void 0 : clientPostgresBindings.length) !== null && _a !== void 0 ? _a : 0;\n          const newPostgresBindings = [];\n          for (let i = 0; i < bindingsLen; i++) {\n            const clientPostgresBinding = clientPostgresBindings[i];\n            const {\n              filter: {\n                event,\n                schema,\n                table,\n                filter\n              }\n            } = clientPostgresBinding;\n            const serverPostgresFilter = postgres_changes && postgres_changes[i];\n            if (serverPostgresFilter && serverPostgresFilter.event === event && RealtimeChannel.isFilterValueEqual(serverPostgresFilter.schema, schema) && RealtimeChannel.isFilterValueEqual(serverPostgresFilter.table, table) && RealtimeChannel.isFilterValueEqual(serverPostgresFilter.filter, filter)) {\n              newPostgresBindings.push(Object.assign(Object.assign({}, clientPostgresBinding), {\n                id: serverPostgresFilter.id\n              }));\n            } else {\n              this.unsubscribe();\n              this.state = CHANNEL_STATES.errored;\n              callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error('mismatch between server and client bindings for postgres changes'));\n              return;\n            }\n          }\n          this.bindings.postgres_changes = newPostgresBindings;\n          callback && callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);\n          return;\n        }\n      }).receive('error', error => {\n        this.state = CHANNEL_STATES.errored;\n        callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error(JSON.stringify(Object.values(error).join(', ') || 'error')));\n        return;\n      }).receive('timeout', () => {\n        callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.TIMED_OUT);\n        return;\n      });\n    }\n    return this;\n  }\n  /**\r\n   * Returns the current presence state for this channel.\r\n   *\r\n   * The shape is a map keyed by presence key (for example a user id) where each entry contains the\r\n   * tracked metadata for that user.\r\n   */\n  presenceState() {\n    return this.presence.state;\n  }\n  /**\r\n   * Sends the supplied payload to the presence tracker so other subscribers can see that this\r\n   * client is online. Use `untrack` to stop broadcasting presence for the same key.\r\n   */\n  async track(payload, opts = {}) {\n    return await this.send({\n      type: 'presence',\n      event: 'track',\n      payload\n    }, opts.timeout || this.timeout);\n  }\n  /**\r\n   * Removes the current presence state for this client.\r\n   */\n  async untrack(opts = {}) {\n    return await this.send({\n      type: 'presence',\n      event: 'untrack'\n    }, opts);\n  }\n  on(type, filter, callback) {\n    if (this.state === CHANNEL_STATES.joined && type === REALTIME_LISTEN_TYPES.PRESENCE) {\n      this.socket.log('channel', `resubscribe to ${this.topic} due to change in presence callbacks on joined channel`);\n      this.unsubscribe().then(async () => await this.subscribe());\n    }\n    return this._on(type, filter, callback);\n  }\n  /**\r\n   * Sends a broadcast message explicitly via REST API.\r\n   *\r\n   * This method always uses the REST API endpoint regardless of WebSocket connection state.\r\n   * Useful when you want to guarantee REST delivery or when gradually migrating from implicit REST fallback.\r\n   *\r\n   * @param event The name of the broadcast event\r\n   * @param payload Payload to be sent (required)\r\n   * @param opts Options including timeout\r\n   * @returns Promise resolving to object with success status, and error details if failed\r\n   */\n  async httpSend(event, payload, opts = {}) {\n    var _a;\n    if (payload === undefined || payload === null) {\n      return Promise.reject('Payload is required for httpSend()');\n    }\n    const headers = {\n      apikey: this.socket.apiKey ? this.socket.apiKey : '',\n      'Content-Type': 'application/json'\n    };\n    if (this.socket.accessTokenValue) {\n      headers['Authorization'] = `Bearer ${this.socket.accessTokenValue}`;\n    }\n    const options = {\n      method: 'POST',\n      headers,\n      body: JSON.stringify({\n        messages: [{\n          topic: this.subTopic,\n          event,\n          payload: payload,\n          private: this.private\n        }]\n      })\n    };\n    const response = await this._fetchWithTimeout(this.broadcastEndpointURL, options, (_a = opts.timeout) !== null && _a !== void 0 ? _a : this.timeout);\n    if (response.status === 202) {\n      return {\n        success: true\n      };\n    }\n    let errorMessage = response.statusText;\n    try {\n      const errorBody = await response.json();\n      errorMessage = errorBody.error || errorBody.message || errorMessage;\n    } catch (_b) {}\n    return Promise.reject(new Error(errorMessage));\n  }\n  /**\r\n   * Sends a message into the channel.\r\n   *\r\n   * @param args Arguments to send to channel\r\n   * @param args.type The type of event to send\r\n   * @param args.event The name of the event being sent\r\n   * @param args.payload Payload to be sent\r\n   * @param opts Options to be used during the send process\r\n   */\n  async send(args, opts = {}) {\n    var _a, _b;\n    if (!this._canPush() && args.type === 'broadcast') {\n      console.warn('Realtime send() is automatically falling back to REST API. ' + 'This behavior will be deprecated in the future. ' + 'Please use httpSend() explicitly for REST delivery.');\n      const {\n        event,\n        payload: endpoint_payload\n      } = args;\n      const headers = {\n        apikey: this.socket.apiKey ? this.socket.apiKey : '',\n        'Content-Type': 'application/json'\n      };\n      if (this.socket.accessTokenValue) {\n        headers['Authorization'] = `Bearer ${this.socket.accessTokenValue}`;\n      }\n      const options = {\n        method: 'POST',\n        headers,\n        body: JSON.stringify({\n          messages: [{\n            topic: this.subTopic,\n            event,\n            payload: endpoint_payload,\n            private: this.private\n          }]\n        })\n      };\n      try {\n        const response = await this._fetchWithTimeout(this.broadcastEndpointURL, options, (_a = opts.timeout) !== null && _a !== void 0 ? _a : this.timeout);\n        await ((_b = response.body) === null || _b === void 0 ? void 0 : _b.cancel());\n        return response.ok ? 'ok' : 'error';\n      } catch (error) {\n        if (error.name === 'AbortError') {\n          return 'timed out';\n        } else {\n          return 'error';\n        }\n      }\n    } else {\n      return new Promise(resolve => {\n        var _a, _b, _c;\n        const push = this._push(args.type, args, opts.timeout || this.timeout);\n        if (args.type === 'broadcast' && !((_c = (_b = (_a = this.params) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.broadcast) === null || _c === void 0 ? void 0 : _c.ack)) {\n          resolve('ok');\n        }\n        push.receive('ok', () => resolve('ok'));\n        push.receive('error', () => resolve('error'));\n        push.receive('timeout', () => resolve('timed out'));\n      });\n    }\n  }\n  /**\r\n   * Updates the payload that will be sent the next time the channel joins (reconnects).\r\n   * Useful for rotating access tokens or updating config without re-creating the channel.\r\n   */\n  updateJoinPayload(payload) {\n    this.joinPush.updatePayload(payload);\n  }\n  /**\r\n   * Leaves the channel.\r\n   *\r\n   * Unsubscribes from server events, and instructs channel to terminate on server.\r\n   * Triggers onClose() hooks.\r\n   *\r\n   * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\r\n   * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\r\n   */\n  unsubscribe(timeout = this.timeout) {\n    this.state = CHANNEL_STATES.leaving;\n    const onClose = () => {\n      this.socket.log('channel', `leave ${this.topic}`);\n      this._trigger(CHANNEL_EVENTS.close, 'leave', this._joinRef());\n    };\n    this.joinPush.destroy();\n    let leavePush = null;\n    return new Promise(resolve => {\n      leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout);\n      leavePush.receive('ok', () => {\n        onClose();\n        resolve('ok');\n      }).receive('timeout', () => {\n        onClose();\n        resolve('timed out');\n      }).receive('error', () => {\n        resolve('error');\n      });\n      leavePush.send();\n      if (!this._canPush()) {\n        leavePush.trigger('ok', {});\n      }\n    }).finally(() => {\n      leavePush === null || leavePush === void 0 ? void 0 : leavePush.destroy();\n    });\n  }\n  /**\r\n   * Teardown the channel.\r\n   *\r\n   * Destroys and stops related timers.\r\n   */\n  teardown() {\n    this.pushBuffer.forEach(push => push.destroy());\n    this.pushBuffer = [];\n    this.rejoinTimer.reset();\n    this.joinPush.destroy();\n    this.state = CHANNEL_STATES.closed;\n    this.bindings = {};\n  }\n  /** @internal */\n  async _fetchWithTimeout(url, options, timeout) {\n    const controller = new AbortController();\n    const id = setTimeout(() => controller.abort(), timeout);\n    const response = await this.socket.fetch(url, Object.assign(Object.assign({}, options), {\n      signal: controller.signal\n    }));\n    clearTimeout(id);\n    return response;\n  }\n  /** @internal */\n  _push(event, payload, timeout = this.timeout) {\n    if (!this.joinedOnce) {\n      throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;\n    }\n    let pushEvent = new Push(this, event, payload, timeout);\n    if (this._canPush()) {\n      pushEvent.send();\n    } else {\n      this._addToPushBuffer(pushEvent);\n    }\n    return pushEvent;\n  }\n  /** @internal */\n  _addToPushBuffer(pushEvent) {\n    pushEvent.startTimeout();\n    this.pushBuffer.push(pushEvent);\n    // Enforce buffer size limit\n    if (this.pushBuffer.length > MAX_PUSH_BUFFER_SIZE) {\n      const removedPush = this.pushBuffer.shift();\n      if (removedPush) {\n        removedPush.destroy();\n        this.socket.log('channel', `discarded push due to buffer overflow: ${removedPush.event}`, removedPush.payload);\n      }\n    }\n  }\n  /**\r\n   * Overridable message hook\r\n   *\r\n   * Receives all events for specialized message handling before dispatching to the channel callbacks.\r\n   * Must return the payload, modified or unmodified.\r\n   *\r\n   * @internal\r\n   */\n  _onMessage(_event, payload, _ref) {\n    return payload;\n  }\n  /** @internal */\n  _isMember(topic) {\n    return this.topic === topic;\n  }\n  /** @internal */\n  _joinRef() {\n    return this.joinPush.ref;\n  }\n  /** @internal */\n  _trigger(type, payload, ref) {\n    var _a, _b;\n    const typeLower = type.toLocaleLowerCase();\n    const {\n      close,\n      error,\n      leave,\n      join\n    } = CHANNEL_EVENTS;\n    const events = [close, error, leave, join];\n    if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {\n      return;\n    }\n    let handledPayload = this._onMessage(typeLower, payload, ref);\n    if (payload && !handledPayload) {\n      throw 'channel onMessage callbacks must return the payload, modified or unmodified';\n    }\n    if (['insert', 'update', 'delete'].includes(typeLower)) {\n      (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.filter(bind => {\n        var _a, _b, _c;\n        return ((_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event) === '*' || ((_c = (_b = bind.filter) === null || _b === void 0 ? void 0 : _b.event) === null || _c === void 0 ? void 0 : _c.toLocaleLowerCase()) === typeLower;\n      }).map(bind => bind.callback(handledPayload, ref));\n    } else {\n      (_b = this.bindings[typeLower]) === null || _b === void 0 ? void 0 : _b.filter(bind => {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        if (['broadcast', 'presence', 'postgres_changes'].includes(typeLower)) {\n          if ('id' in bind) {\n            const bindId = bind.id;\n            const bindEvent = (_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event;\n            return bindId && ((_b = payload.ids) === null || _b === void 0 ? void 0 : _b.includes(bindId)) && (bindEvent === '*' || (bindEvent === null || bindEvent === void 0 ? void 0 : bindEvent.toLocaleLowerCase()) === ((_c = payload.data) === null || _c === void 0 ? void 0 : _c.type.toLocaleLowerCase())) && (!((_d = bind.filter) === null || _d === void 0 ? void 0 : _d.table) || bind.filter.table === ((_e = payload.data) === null || _e === void 0 ? void 0 : _e.table));\n          } else {\n            const bindEvent = (_g = (_f = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _f === void 0 ? void 0 : _f.event) === null || _g === void 0 ? void 0 : _g.toLocaleLowerCase();\n            return bindEvent === '*' || bindEvent === ((_h = payload === null || payload === void 0 ? void 0 : payload.event) === null || _h === void 0 ? void 0 : _h.toLocaleLowerCase());\n          }\n        } else {\n          return bind.type.toLocaleLowerCase() === typeLower;\n        }\n      }).map(bind => {\n        if (typeof handledPayload === 'object' && 'ids' in handledPayload) {\n          const postgresChanges = handledPayload.data;\n          const {\n            schema,\n            table,\n            commit_timestamp,\n            type,\n            errors\n          } = postgresChanges;\n          const enrichedPayload = {\n            schema: schema,\n            table: table,\n            commit_timestamp: commit_timestamp,\n            eventType: type,\n            new: {},\n            old: {},\n            errors: errors\n          };\n          handledPayload = Object.assign(Object.assign({}, enrichedPayload), this._getPayloadRecords(postgresChanges));\n        }\n        bind.callback(handledPayload, ref);\n      });\n    }\n  }\n  /** @internal */\n  _isClosed() {\n    return this.state === CHANNEL_STATES.closed;\n  }\n  /** @internal */\n  _isJoined() {\n    return this.state === CHANNEL_STATES.joined;\n  }\n  /** @internal */\n  _isJoining() {\n    return this.state === CHANNEL_STATES.joining;\n  }\n  /** @internal */\n  _isLeaving() {\n    return this.state === CHANNEL_STATES.leaving;\n  }\n  /** @internal */\n  _replyEventName(ref) {\n    return `chan_reply_${ref}`;\n  }\n  /** @internal */\n  _on(type, filter, callback) {\n    const typeLower = type.toLocaleLowerCase();\n    const binding = {\n      type: typeLower,\n      filter: filter,\n      callback: callback\n    };\n    if (this.bindings[typeLower]) {\n      this.bindings[typeLower].push(binding);\n    } else {\n      this.bindings[typeLower] = [binding];\n    }\n    return this;\n  }\n  /** @internal */\n  _off(type, filter) {\n    const typeLower = type.toLocaleLowerCase();\n    if (this.bindings[typeLower]) {\n      this.bindings[typeLower] = this.bindings[typeLower].filter(bind => {\n        var _a;\n        return !(((_a = bind.type) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) === typeLower && RealtimeChannel.isEqual(bind.filter, filter));\n      });\n    }\n    return this;\n  }\n  /** @internal */\n  static isEqual(obj1, obj2) {\n    if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n      return false;\n    }\n    for (const k in obj1) {\n      if (obj1[k] !== obj2[k]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\r\n   * Compares two optional filter values for equality.\r\n   * Treats undefined, null, and empty string as equivalent empty values.\r\n   * @internal\r\n   */\n  static isFilterValueEqual(serverValue, clientValue) {\n    const normalizedServer = serverValue !== null && serverValue !== void 0 ? serverValue : undefined;\n    const normalizedClient = clientValue !== null && clientValue !== void 0 ? clientValue : undefined;\n    return normalizedServer === normalizedClient;\n  }\n  /** @internal */\n  _rejoinUntilConnected() {\n    this.rejoinTimer.scheduleTimeout();\n    if (this.socket.isConnected()) {\n      this._rejoin();\n    }\n  }\n  /**\r\n   * Registers a callback that will be executed when the channel closes.\r\n   *\r\n   * @internal\r\n   */\n  _onClose(callback) {\n    this._on(CHANNEL_EVENTS.close, {}, callback);\n  }\n  /**\r\n   * Registers a callback that will be executed when the channel encounteres an error.\r\n   *\r\n   * @internal\r\n   */\n  _onError(callback) {\n    this._on(CHANNEL_EVENTS.error, {}, reason => callback(reason));\n  }\n  /**\r\n   * Returns `true` if the socket is connected and the channel has been joined.\r\n   *\r\n   * @internal\r\n   */\n  _canPush() {\n    return this.socket.isConnected() && this._isJoined();\n  }\n  /** @internal */\n  _rejoin(timeout = this.timeout) {\n    if (this._isLeaving()) {\n      return;\n    }\n    this.socket._leaveOpenTopic(this.topic);\n    this.state = CHANNEL_STATES.joining;\n    this.joinPush.resend(timeout);\n  }\n  /** @internal */\n  _getPayloadRecords(payload) {\n    const records = {\n      new: {},\n      old: {}\n    };\n    if (payload.type === 'INSERT' || payload.type === 'UPDATE') {\n      records.new = Transformers.convertChangeData(payload.columns, payload.record);\n    }\n    if (payload.type === 'UPDATE' || payload.type === 'DELETE') {\n      records.old = Transformers.convertChangeData(payload.columns, payload.old_record);\n    }\n    return records;\n  }\n}","map":{"version":3,"names":["CHANNEL_EVENTS","CHANNEL_STATES","MAX_PUSH_BUFFER_SIZE","Push","Timer","RealtimePresence","Transformers","httpEndpointURL","REALTIME_POSTGRES_CHANGES_LISTEN_EVENT","REALTIME_LISTEN_TYPES","REALTIME_SUBSCRIBE_STATES","REALTIME_CHANNEL_STATES","RealtimeChannel","constructor","topic","params","config","socket","bindings","state","closed","joinedOnce","pushBuffer","subTopic","replace","Object","assign","broadcast","ack","self","presence","key","enabled","private","timeout","joinPush","join","rejoinTimer","_rejoinUntilConnected","reconnectAfterMs","receive","joined","reset","forEach","pushEvent","send","_onClose","log","_joinRef","_remove","_onError","reason","_isLeaving","_isClosed","errored","scheduleTimeout","_isJoining","_on","reply","payload","ref","_trigger","_replyEventName","broadcastEndpointURL","endPoint","_b","_a","replay","subscribe","callback","isConnected","connect","isPrivate","postgres_changes","map","r","filter","presence_enabled","PRESENCE","length","_c","accessTokenPayload","accessTokenValue","access_token","e","CHANNEL_ERROR","CLOSED","updateJoinPayload","_rejoin","_isManualToken","setAuth","undefined","SUBSCRIBED","clientPostgresBindings","bindingsLen","newPostgresBindings","i","clientPostgresBinding","event","schema","table","serverPostgresFilter","isFilterValueEqual","push","id","unsubscribe","Error","error","JSON","stringify","values","TIMED_OUT","presenceState","track","opts","type","untrack","on","then","httpSend","Promise","reject","headers","apikey","apiKey","options","method","body","messages","response","_fetchWithTimeout","status","success","errorMessage","statusText","errorBody","json","message","args","_canPush","console","warn","endpoint_payload","cancel","ok","name","resolve","_push","updatePayload","leaving","onClose","close","destroy","leavePush","leave","trigger","finally","teardown","url","controller","AbortController","setTimeout","abort","fetch","signal","clearTimeout","_addToPushBuffer","startTimeout","removedPush","shift","_onMessage","_event","_ref","_isMember","typeLower","toLocaleLowerCase","events","indexOf","handledPayload","includes","bind","bindId","bindEvent","ids","data","_d","_e","_g","_f","_h","postgresChanges","commit_timestamp","errors","enrichedPayload","eventType","new","old","_getPayloadRecords","_isJoined","joining","binding","_off","isEqual","obj1","obj2","keys","k","serverValue","clientValue","normalizedServer","normalizedClient","_leaveOpenTopic","resend","records","convertChangeData","columns","record","old_record"],"sources":["C:\\Users\\afonso\\Desktop\\faculdade\\node_modules\\@supabase\\realtime-js\\src\\RealtimeChannel.ts"],"sourcesContent":["import { CHANNEL_EVENTS, CHANNEL_STATES, MAX_PUSH_BUFFER_SIZE } from './lib/constants'\r\nimport Push from './lib/push'\r\nimport type RealtimeClient from './RealtimeClient'\r\nimport Timer from './lib/timer'\r\nimport RealtimePresence, { REALTIME_PRESENCE_LISTEN_EVENTS } from './RealtimePresence'\r\nimport type {\r\n  RealtimePresenceJoinPayload,\r\n  RealtimePresenceLeavePayload,\r\n  RealtimePresenceState,\r\n} from './RealtimePresence'\r\nimport * as Transformers from './lib/transformers'\r\nimport { httpEndpointURL } from './lib/transformers'\r\n\r\ntype ReplayOption = {\r\n  since: number\r\n  limit?: number\r\n}\r\n\r\nexport type RealtimeChannelOptions = {\r\n  config: {\r\n    /**\r\n     * self option enables client to receive message it broadcast\r\n     * ack option instructs server to acknowledge that broadcast message was received\r\n     * replay option instructs server to replay broadcast messages\r\n     */\r\n    broadcast?: { self?: boolean; ack?: boolean; replay?: ReplayOption }\r\n    /**\r\n     * key option is used to track presence payload across clients\r\n     */\r\n    presence?: { key?: string; enabled?: boolean }\r\n    /**\r\n     * defines if the channel is private or not and if RLS policies will be used to check data\r\n     */\r\n    private?: boolean\r\n  }\r\n}\r\n\r\ntype RealtimeChangesPayloadBase = {\r\n  schema: string\r\n  table: string\r\n}\r\n\r\ntype RealtimeBroadcastChangesPayloadBase = RealtimeChangesPayloadBase & {\r\n  id: string\r\n}\r\n\r\nexport type RealtimeBroadcastInsertPayload<T extends { [key: string]: any }> =\r\n  RealtimeBroadcastChangesPayloadBase & {\r\n    operation: `${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.INSERT}`\r\n    record: T\r\n    old_record: null\r\n  }\r\n\r\nexport type RealtimeBroadcastUpdatePayload<T extends { [key: string]: any }> =\r\n  RealtimeBroadcastChangesPayloadBase & {\r\n    operation: `${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.UPDATE}`\r\n    record: T\r\n    old_record: T\r\n  }\r\n\r\nexport type RealtimeBroadcastDeletePayload<T extends { [key: string]: any }> =\r\n  RealtimeBroadcastChangesPayloadBase & {\r\n    operation: `${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.DELETE}`\r\n    record: null\r\n    old_record: T\r\n  }\r\n\r\nexport type RealtimeBroadcastPayload<T extends { [key: string]: any }> =\r\n  | RealtimeBroadcastInsertPayload<T>\r\n  | RealtimeBroadcastUpdatePayload<T>\r\n  | RealtimeBroadcastDeletePayload<T>\r\n\r\ntype RealtimePostgresChangesPayloadBase = {\r\n  schema: string\r\n  table: string\r\n  commit_timestamp: string\r\n  errors: string[]\r\n}\r\n\r\nexport type RealtimePostgresInsertPayload<T extends { [key: string]: any }> =\r\n  RealtimePostgresChangesPayloadBase & {\r\n    eventType: `${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.INSERT}`\r\n    new: T\r\n    old: {}\r\n  }\r\n\r\nexport type RealtimePostgresUpdatePayload<T extends { [key: string]: any }> =\r\n  RealtimePostgresChangesPayloadBase & {\r\n    eventType: `${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.UPDATE}`\r\n    new: T\r\n    old: Partial<T>\r\n  }\r\n\r\nexport type RealtimePostgresDeletePayload<T extends { [key: string]: any }> =\r\n  RealtimePostgresChangesPayloadBase & {\r\n    eventType: `${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.DELETE}`\r\n    new: {}\r\n    old: Partial<T>\r\n  }\r\n\r\nexport type RealtimePostgresChangesPayload<T extends { [key: string]: any }> =\r\n  | RealtimePostgresInsertPayload<T>\r\n  | RealtimePostgresUpdatePayload<T>\r\n  | RealtimePostgresDeletePayload<T>\r\n\r\nexport type RealtimePostgresChangesFilter<T extends `${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT}`> = {\r\n  /**\r\n   * The type of database change to listen to.\r\n   */\r\n  event: T\r\n  /**\r\n   * The database schema to listen to.\r\n   */\r\n  schema: string\r\n  /**\r\n   * The database table to listen to.\r\n   */\r\n  table?: string\r\n  /**\r\n   * Receive database changes when filter is matched.\r\n   */\r\n  filter?: string\r\n}\r\n\r\nexport type RealtimeChannelSendResponse = 'ok' | 'timed out' | 'error'\r\n\r\nexport enum REALTIME_POSTGRES_CHANGES_LISTEN_EVENT {\r\n  ALL = '*',\r\n  INSERT = 'INSERT',\r\n  UPDATE = 'UPDATE',\r\n  DELETE = 'DELETE',\r\n}\r\n\r\nexport enum REALTIME_LISTEN_TYPES {\r\n  BROADCAST = 'broadcast',\r\n  PRESENCE = 'presence',\r\n  POSTGRES_CHANGES = 'postgres_changes',\r\n  SYSTEM = 'system',\r\n}\r\n\r\nexport enum REALTIME_SUBSCRIBE_STATES {\r\n  SUBSCRIBED = 'SUBSCRIBED',\r\n  TIMED_OUT = 'TIMED_OUT',\r\n  CLOSED = 'CLOSED',\r\n  CHANNEL_ERROR = 'CHANNEL_ERROR',\r\n}\r\n\r\nexport const REALTIME_CHANNEL_STATES = CHANNEL_STATES\r\n\r\ninterface PostgresChangesFilters {\r\n  postgres_changes: {\r\n    id: string\r\n    event: string\r\n    schema?: string\r\n    table?: string\r\n    filter?: string\r\n  }[]\r\n}\r\n/** A channel is the basic building block of Realtime\r\n * and narrows the scope of data flow to subscribed clients.\r\n * You can think of a channel as a chatroom where participants are able to see who's online\r\n * and send and receive messages.\r\n */\r\nexport default class RealtimeChannel {\r\n  bindings: {\r\n    [key: string]: {\r\n      type: string\r\n      filter: { [key: string]: any }\r\n      callback: Function\r\n      id?: string\r\n    }[]\r\n  } = {}\r\n  timeout: number\r\n  state: CHANNEL_STATES = CHANNEL_STATES.closed\r\n  joinedOnce = false\r\n  joinPush: Push\r\n  rejoinTimer: Timer\r\n  pushBuffer: Push[] = []\r\n  presence: RealtimePresence\r\n  broadcastEndpointURL: string\r\n  subTopic: string\r\n  private: boolean\r\n\r\n  /**\r\n   * Creates a channel that can broadcast messages, sync presence, and listen to Postgres changes.\r\n   *\r\n   * The topic determines which realtime stream you are subscribing to. Config options let you\r\n   * enable acknowledgement for broadcasts, presence tracking, or private channels.\r\n   *\r\n   * @example\r\n   * ```ts\r\n   * import RealtimeClient from '@supabase/realtime-js'\r\n   *\r\n   * const client = new RealtimeClient('https://xyzcompany.supabase.co/realtime/v1', {\r\n   *   params: { apikey: 'public-anon-key' },\r\n   * })\r\n   * const channel = new RealtimeChannel('realtime:public:messages', { config: {} }, client)\r\n   * ```\r\n   */\r\n  constructor(\r\n    /** Topic name can be any string. */\r\n    public topic: string,\r\n    public params: RealtimeChannelOptions = { config: {} },\r\n    public socket: RealtimeClient\r\n  ) {\r\n    this.subTopic = topic.replace(/^realtime:/i, '')\r\n    this.params.config = {\r\n      ...{\r\n        broadcast: { ack: false, self: false },\r\n        presence: { key: '', enabled: false },\r\n        private: false,\r\n      },\r\n      ...params.config,\r\n    }\r\n    this.timeout = this.socket.timeout\r\n    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout)\r\n    this.rejoinTimer = new Timer(() => this._rejoinUntilConnected(), this.socket.reconnectAfterMs)\r\n    this.joinPush.receive('ok', () => {\r\n      this.state = CHANNEL_STATES.joined\r\n      this.rejoinTimer.reset()\r\n      this.pushBuffer.forEach((pushEvent: Push) => pushEvent.send())\r\n      this.pushBuffer = []\r\n    })\r\n    this._onClose(() => {\r\n      this.rejoinTimer.reset()\r\n      this.socket.log('channel', `close ${this.topic} ${this._joinRef()}`)\r\n      this.state = CHANNEL_STATES.closed\r\n      this.socket._remove(this)\r\n    })\r\n    this._onError((reason: string) => {\r\n      if (this._isLeaving() || this._isClosed()) {\r\n        return\r\n      }\r\n      this.socket.log('channel', `error ${this.topic}`, reason)\r\n      this.state = CHANNEL_STATES.errored\r\n      this.rejoinTimer.scheduleTimeout()\r\n    })\r\n    this.joinPush.receive('timeout', () => {\r\n      if (!this._isJoining()) {\r\n        return\r\n      }\r\n      this.socket.log('channel', `timeout ${this.topic}`, this.joinPush.timeout)\r\n      this.state = CHANNEL_STATES.errored\r\n      this.rejoinTimer.scheduleTimeout()\r\n    })\r\n\r\n    this.joinPush.receive('error', (reason: any) => {\r\n      if (this._isLeaving() || this._isClosed()) {\r\n        return\r\n      }\r\n      this.socket.log('channel', `error ${this.topic}`, reason)\r\n      this.state = CHANNEL_STATES.errored\r\n      this.rejoinTimer.scheduleTimeout()\r\n    })\r\n    this._on(CHANNEL_EVENTS.reply, {}, (payload: any, ref: string) => {\r\n      this._trigger(this._replyEventName(ref), payload)\r\n    })\r\n\r\n    this.presence = new RealtimePresence(this)\r\n\r\n    this.broadcastEndpointURL = httpEndpointURL(this.socket.endPoint)\r\n    this.private = this.params.config.private || false\r\n\r\n    if (!this.private && this.params.config?.broadcast?.replay) {\r\n      throw `tried to use replay on public channel '${this.topic}'. It must be a private channel.`\r\n    }\r\n  }\r\n\r\n  /** Subscribe registers your client with the server */\r\n  subscribe(\r\n    callback?: (status: REALTIME_SUBSCRIBE_STATES, err?: Error) => void,\r\n    timeout = this.timeout\r\n  ): RealtimeChannel {\r\n    if (!this.socket.isConnected()) {\r\n      this.socket.connect()\r\n    }\r\n    if (this.state == CHANNEL_STATES.closed) {\r\n      const {\r\n        config: { broadcast, presence, private: isPrivate },\r\n      } = this.params\r\n\r\n      const postgres_changes = this.bindings.postgres_changes?.map((r) => r.filter) ?? []\r\n\r\n      const presence_enabled =\r\n        (!!this.bindings[REALTIME_LISTEN_TYPES.PRESENCE] &&\r\n          this.bindings[REALTIME_LISTEN_TYPES.PRESENCE].length > 0) ||\r\n        this.params.config.presence?.enabled === true\r\n      const accessTokenPayload: { access_token?: string } = {}\r\n      const config = {\r\n        broadcast,\r\n        presence: { ...presence, enabled: presence_enabled },\r\n        postgres_changes,\r\n        private: isPrivate,\r\n      }\r\n\r\n      if (this.socket.accessTokenValue) {\r\n        accessTokenPayload.access_token = this.socket.accessTokenValue\r\n      }\r\n\r\n      this._onError((e: Error) => callback?.(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, e))\r\n\r\n      this._onClose(() => callback?.(REALTIME_SUBSCRIBE_STATES.CLOSED))\r\n\r\n      this.updateJoinPayload({ ...{ config }, ...accessTokenPayload })\r\n\r\n      this.joinedOnce = true\r\n      this._rejoin(timeout)\r\n\r\n      this.joinPush\r\n        .receive('ok', async ({ postgres_changes }: PostgresChangesFilters) => {\r\n          // Only refresh auth if using callback-based tokens\r\n          if (!this.socket._isManualToken()) {\r\n            this.socket.setAuth()\r\n          }\r\n          if (postgres_changes === undefined) {\r\n            callback?.(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED)\r\n            return\r\n          } else {\r\n            const clientPostgresBindings = this.bindings.postgres_changes\r\n            const bindingsLen = clientPostgresBindings?.length ?? 0\r\n            const newPostgresBindings = []\r\n\r\n            for (let i = 0; i < bindingsLen; i++) {\r\n              const clientPostgresBinding = clientPostgresBindings[i]\r\n              const {\r\n                filter: { event, schema, table, filter },\r\n              } = clientPostgresBinding\r\n              const serverPostgresFilter = postgres_changes && postgres_changes[i]\r\n\r\n              if (\r\n                serverPostgresFilter &&\r\n                serverPostgresFilter.event === event &&\r\n                RealtimeChannel.isFilterValueEqual(serverPostgresFilter.schema, schema) &&\r\n                RealtimeChannel.isFilterValueEqual(serverPostgresFilter.table, table) &&\r\n                RealtimeChannel.isFilterValueEqual(serverPostgresFilter.filter, filter)\r\n              ) {\r\n                newPostgresBindings.push({\r\n                  ...clientPostgresBinding,\r\n                  id: serverPostgresFilter.id,\r\n                })\r\n              } else {\r\n                this.unsubscribe()\r\n                this.state = CHANNEL_STATES.errored\r\n\r\n                callback?.(\r\n                  REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR,\r\n                  new Error('mismatch between server and client bindings for postgres changes')\r\n                )\r\n                return\r\n              }\r\n            }\r\n\r\n            this.bindings.postgres_changes = newPostgresBindings\r\n\r\n            callback && callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED)\r\n            return\r\n          }\r\n        })\r\n        .receive('error', (error: { [key: string]: any }) => {\r\n          this.state = CHANNEL_STATES.errored\r\n          callback?.(\r\n            REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR,\r\n            new Error(JSON.stringify(Object.values(error).join(', ') || 'error'))\r\n          )\r\n          return\r\n        })\r\n        .receive('timeout', () => {\r\n          callback?.(REALTIME_SUBSCRIBE_STATES.TIMED_OUT)\r\n          return\r\n        })\r\n    }\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Returns the current presence state for this channel.\r\n   *\r\n   * The shape is a map keyed by presence key (for example a user id) where each entry contains the\r\n   * tracked metadata for that user.\r\n   */\r\n  presenceState<T extends { [key: string]: any } = {}>(): RealtimePresenceState<T> {\r\n    return this.presence.state as RealtimePresenceState<T>\r\n  }\r\n\r\n  /**\r\n   * Sends the supplied payload to the presence tracker so other subscribers can see that this\r\n   * client is online. Use `untrack` to stop broadcasting presence for the same key.\r\n   */\r\n  async track(\r\n    payload: { [key: string]: any },\r\n    opts: { [key: string]: any } = {}\r\n  ): Promise<RealtimeChannelSendResponse> {\r\n    return await this.send(\r\n      {\r\n        type: 'presence',\r\n        event: 'track',\r\n        payload,\r\n      },\r\n      opts.timeout || this.timeout\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Removes the current presence state for this client.\r\n   */\r\n  async untrack(opts: { [key: string]: any } = {}): Promise<RealtimeChannelSendResponse> {\r\n    return await this.send(\r\n      {\r\n        type: 'presence',\r\n        event: 'untrack',\r\n      },\r\n      opts\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Creates an event handler that listens to changes.\r\n   */\r\n  on(\r\n    type: `${REALTIME_LISTEN_TYPES.PRESENCE}`,\r\n    filter: { event: `${REALTIME_PRESENCE_LISTEN_EVENTS.SYNC}` },\r\n    callback: () => void\r\n  ): RealtimeChannel\r\n  on<T extends { [key: string]: any }>(\r\n    type: `${REALTIME_LISTEN_TYPES.PRESENCE}`,\r\n    filter: { event: `${REALTIME_PRESENCE_LISTEN_EVENTS.JOIN}` },\r\n    callback: (payload: RealtimePresenceJoinPayload<T>) => void\r\n  ): RealtimeChannel\r\n  on<T extends { [key: string]: any }>(\r\n    type: `${REALTIME_LISTEN_TYPES.PRESENCE}`,\r\n    filter: { event: `${REALTIME_PRESENCE_LISTEN_EVENTS.LEAVE}` },\r\n    callback: (payload: RealtimePresenceLeavePayload<T>) => void\r\n  ): RealtimeChannel\r\n  on<T extends { [key: string]: any }>(\r\n    type: `${REALTIME_LISTEN_TYPES.POSTGRES_CHANGES}`,\r\n    filter: RealtimePostgresChangesFilter<`${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.ALL}`>,\r\n    callback: (payload: RealtimePostgresChangesPayload<T>) => void\r\n  ): RealtimeChannel\r\n  on<T extends { [key: string]: any }>(\r\n    type: `${REALTIME_LISTEN_TYPES.POSTGRES_CHANGES}`,\r\n    filter: RealtimePostgresChangesFilter<`${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.INSERT}`>,\r\n    callback: (payload: RealtimePostgresInsertPayload<T>) => void\r\n  ): RealtimeChannel\r\n  on<T extends { [key: string]: any }>(\r\n    type: `${REALTIME_LISTEN_TYPES.POSTGRES_CHANGES}`,\r\n    filter: RealtimePostgresChangesFilter<`${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.UPDATE}`>,\r\n    callback: (payload: RealtimePostgresUpdatePayload<T>) => void\r\n  ): RealtimeChannel\r\n  on<T extends { [key: string]: any }>(\r\n    type: `${REALTIME_LISTEN_TYPES.POSTGRES_CHANGES}`,\r\n    filter: RealtimePostgresChangesFilter<`${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.DELETE}`>,\r\n    callback: (payload: RealtimePostgresDeletePayload<T>) => void\r\n  ): RealtimeChannel\r\n  /**\r\n   * The following is placed here to display on supabase.com/docs/reference/javascript/subscribe.\r\n   * @param type One of \"broadcast\", \"presence\", or \"postgres_changes\".\r\n   * @param filter Custom object specific to the Realtime feature detailing which payloads to receive.\r\n   * @param callback Function to be invoked when event handler is triggered.\r\n   */\r\n  on(\r\n    type: `${REALTIME_LISTEN_TYPES.BROADCAST}`,\r\n    filter: { event: string },\r\n    callback: (payload: {\r\n      type: `${REALTIME_LISTEN_TYPES.BROADCAST}`\r\n      event: string\r\n      meta?: {\r\n        replayed?: boolean\r\n        id: string\r\n      }\r\n      [key: string]: any\r\n    }) => void\r\n  ): RealtimeChannel\r\n  on<T extends { [key: string]: any }>(\r\n    type: `${REALTIME_LISTEN_TYPES.BROADCAST}`,\r\n    filter: { event: string },\r\n    callback: (payload: {\r\n      type: `${REALTIME_LISTEN_TYPES.BROADCAST}`\r\n      event: string\r\n      meta?: {\r\n        replayed?: boolean\r\n        id: string\r\n      }\r\n      payload: T\r\n    }) => void\r\n  ): RealtimeChannel\r\n  on<T extends Record<string, unknown>>(\r\n    type: `${REALTIME_LISTEN_TYPES.BROADCAST}`,\r\n    filter: { event: REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.ALL },\r\n    callback: (payload: {\r\n      type: `${REALTIME_LISTEN_TYPES.BROADCAST}`\r\n      event: REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.ALL\r\n      payload: RealtimeBroadcastPayload<T>\r\n    }) => void\r\n  ): RealtimeChannel\r\n  on<T extends { [key: string]: any }>(\r\n    type: `${REALTIME_LISTEN_TYPES.BROADCAST}`,\r\n    filter: { event: REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.INSERT },\r\n    callback: (payload: {\r\n      type: `${REALTIME_LISTEN_TYPES.BROADCAST}`\r\n      event: REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.INSERT\r\n      payload: RealtimeBroadcastInsertPayload<T>\r\n    }) => void\r\n  ): RealtimeChannel\r\n  on<T extends { [key: string]: any }>(\r\n    type: `${REALTIME_LISTEN_TYPES.BROADCAST}`,\r\n    filter: { event: REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.UPDATE },\r\n    callback: (payload: {\r\n      type: `${REALTIME_LISTEN_TYPES.BROADCAST}`\r\n      event: REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.UPDATE\r\n      payload: RealtimeBroadcastUpdatePayload<T>\r\n    }) => void\r\n  ): RealtimeChannel\r\n  on<T extends { [key: string]: any }>(\r\n    type: `${REALTIME_LISTEN_TYPES.BROADCAST}`,\r\n    filter: { event: REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.DELETE },\r\n    callback: (payload: {\r\n      type: `${REALTIME_LISTEN_TYPES.BROADCAST}`\r\n      event: REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.DELETE\r\n      payload: RealtimeBroadcastDeletePayload<T>\r\n    }) => void\r\n  ): RealtimeChannel\r\n  on<T extends { [key: string]: any }>(\r\n    type: `${REALTIME_LISTEN_TYPES.SYSTEM}`,\r\n    filter: {},\r\n    callback: (payload: any) => void\r\n  ): RealtimeChannel\r\n  on(\r\n    type: `${REALTIME_LISTEN_TYPES}`,\r\n    filter: { event: string; [key: string]: string },\r\n    callback: (payload: any) => void\r\n  ): RealtimeChannel {\r\n    if (this.state === CHANNEL_STATES.joined && type === REALTIME_LISTEN_TYPES.PRESENCE) {\r\n      this.socket.log(\r\n        'channel',\r\n        `resubscribe to ${this.topic} due to change in presence callbacks on joined channel`\r\n      )\r\n      this.unsubscribe().then(async () => await this.subscribe())\r\n    }\r\n    return this._on(type, filter, callback)\r\n  }\r\n  /**\r\n   * Sends a broadcast message explicitly via REST API.\r\n   *\r\n   * This method always uses the REST API endpoint regardless of WebSocket connection state.\r\n   * Useful when you want to guarantee REST delivery or when gradually migrating from implicit REST fallback.\r\n   *\r\n   * @param event The name of the broadcast event\r\n   * @param payload Payload to be sent (required)\r\n   * @param opts Options including timeout\r\n   * @returns Promise resolving to object with success status, and error details if failed\r\n   */\r\n  async httpSend(\r\n    event: string,\r\n    payload: any,\r\n    opts: { timeout?: number } = {}\r\n  ): Promise<{ success: true } | { success: false; status: number; error: string }> {\r\n    if (payload === undefined || payload === null) {\r\n      return Promise.reject('Payload is required for httpSend()')\r\n    }\r\n\r\n    const headers: Record<string, string> = {\r\n      apikey: this.socket.apiKey ? this.socket.apiKey : '',\r\n      'Content-Type': 'application/json',\r\n    }\r\n\r\n    if (this.socket.accessTokenValue) {\r\n      headers['Authorization'] = `Bearer ${this.socket.accessTokenValue}`\r\n    }\r\n\r\n    const options = {\r\n      method: 'POST',\r\n      headers,\r\n      body: JSON.stringify({\r\n        messages: [\r\n          {\r\n            topic: this.subTopic,\r\n            event,\r\n            payload: payload,\r\n            private: this.private,\r\n          },\r\n        ],\r\n      }),\r\n    }\r\n\r\n    const response = await this._fetchWithTimeout(\r\n      this.broadcastEndpointURL,\r\n      options,\r\n      opts.timeout ?? this.timeout\r\n    )\r\n\r\n    if (response.status === 202) {\r\n      return { success: true }\r\n    }\r\n\r\n    let errorMessage = response.statusText\r\n    try {\r\n      const errorBody = await response.json()\r\n      errorMessage = errorBody.error || errorBody.message || errorMessage\r\n    } catch {}\r\n\r\n    return Promise.reject(new Error(errorMessage))\r\n  }\r\n\r\n  /**\r\n   * Sends a message into the channel.\r\n   *\r\n   * @param args Arguments to send to channel\r\n   * @param args.type The type of event to send\r\n   * @param args.event The name of the event being sent\r\n   * @param args.payload Payload to be sent\r\n   * @param opts Options to be used during the send process\r\n   */\r\n  async send(\r\n    args: {\r\n      type: 'broadcast' | 'presence' | 'postgres_changes'\r\n      event: string\r\n      payload?: any\r\n      [key: string]: any\r\n    },\r\n    opts: { [key: string]: any } = {}\r\n  ): Promise<RealtimeChannelSendResponse> {\r\n    if (!this._canPush() && args.type === 'broadcast') {\r\n      console.warn(\r\n        'Realtime send() is automatically falling back to REST API. ' +\r\n          'This behavior will be deprecated in the future. ' +\r\n          'Please use httpSend() explicitly for REST delivery.'\r\n      )\r\n\r\n      const { event, payload: endpoint_payload } = args\r\n      const headers: Record<string, string> = {\r\n        apikey: this.socket.apiKey ? this.socket.apiKey : '',\r\n        'Content-Type': 'application/json',\r\n      }\r\n\r\n      if (this.socket.accessTokenValue) {\r\n        headers['Authorization'] = `Bearer ${this.socket.accessTokenValue}`\r\n      }\r\n\r\n      const options = {\r\n        method: 'POST',\r\n        headers,\r\n        body: JSON.stringify({\r\n          messages: [\r\n            {\r\n              topic: this.subTopic,\r\n              event,\r\n              payload: endpoint_payload,\r\n              private: this.private,\r\n            },\r\n          ],\r\n        }),\r\n      }\r\n\r\n      try {\r\n        const response = await this._fetchWithTimeout(\r\n          this.broadcastEndpointURL,\r\n          options,\r\n          opts.timeout ?? this.timeout\r\n        )\r\n\r\n        await response.body?.cancel()\r\n        return response.ok ? 'ok' : 'error'\r\n      } catch (error: any) {\r\n        if (error.name === 'AbortError') {\r\n          return 'timed out'\r\n        } else {\r\n          return 'error'\r\n        }\r\n      }\r\n    } else {\r\n      return new Promise((resolve) => {\r\n        const push = this._push(args.type, args, opts.timeout || this.timeout)\r\n\r\n        if (args.type === 'broadcast' && !this.params?.config?.broadcast?.ack) {\r\n          resolve('ok')\r\n        }\r\n\r\n        push.receive('ok', () => resolve('ok'))\r\n        push.receive('error', () => resolve('error'))\r\n        push.receive('timeout', () => resolve('timed out'))\r\n      })\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates the payload that will be sent the next time the channel joins (reconnects).\r\n   * Useful for rotating access tokens or updating config without re-creating the channel.\r\n   */\r\n  updateJoinPayload(payload: { [key: string]: any }): void {\r\n    this.joinPush.updatePayload(payload)\r\n  }\r\n\r\n  /**\r\n   * Leaves the channel.\r\n   *\r\n   * Unsubscribes from server events, and instructs channel to terminate on server.\r\n   * Triggers onClose() hooks.\r\n   *\r\n   * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\r\n   * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\r\n   */\r\n  unsubscribe(timeout = this.timeout): Promise<'ok' | 'timed out' | 'error'> {\r\n    this.state = CHANNEL_STATES.leaving\r\n    const onClose = () => {\r\n      this.socket.log('channel', `leave ${this.topic}`)\r\n      this._trigger(CHANNEL_EVENTS.close, 'leave', this._joinRef())\r\n    }\r\n\r\n    this.joinPush.destroy()\r\n\r\n    let leavePush: Push | null = null\r\n\r\n    return new Promise<RealtimeChannelSendResponse>((resolve) => {\r\n      leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout)\r\n      leavePush\r\n        .receive('ok', () => {\r\n          onClose()\r\n          resolve('ok')\r\n        })\r\n        .receive('timeout', () => {\r\n          onClose()\r\n          resolve('timed out')\r\n        })\r\n        .receive('error', () => {\r\n          resolve('error')\r\n        })\r\n\r\n      leavePush.send()\r\n      if (!this._canPush()) {\r\n        leavePush.trigger('ok', {})\r\n      }\r\n    }).finally(() => {\r\n      leavePush?.destroy()\r\n    })\r\n  }\r\n  /**\r\n   * Teardown the channel.\r\n   *\r\n   * Destroys and stops related timers.\r\n   */\r\n  teardown() {\r\n    this.pushBuffer.forEach((push: Push) => push.destroy())\r\n    this.pushBuffer = []\r\n    this.rejoinTimer.reset()\r\n    this.joinPush.destroy()\r\n    this.state = CHANNEL_STATES.closed\r\n    this.bindings = {}\r\n  }\r\n\r\n  /** @internal */\r\n\r\n  async _fetchWithTimeout(url: string, options: { [key: string]: any }, timeout: number) {\r\n    const controller = new AbortController()\r\n    const id = setTimeout(() => controller.abort(), timeout)\r\n\r\n    const response = await this.socket.fetch(url, {\r\n      ...options,\r\n      signal: controller.signal,\r\n    })\r\n\r\n    clearTimeout(id)\r\n\r\n    return response\r\n  }\r\n\r\n  /** @internal */\r\n  _push(event: string, payload: { [key: string]: any }, timeout = this.timeout) {\r\n    if (!this.joinedOnce) {\r\n      throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`\r\n    }\r\n    let pushEvent = new Push(this, event, payload, timeout)\r\n    if (this._canPush()) {\r\n      pushEvent.send()\r\n    } else {\r\n      this._addToPushBuffer(pushEvent)\r\n    }\r\n\r\n    return pushEvent\r\n  }\r\n\r\n  /** @internal */\r\n  _addToPushBuffer(pushEvent: Push) {\r\n    pushEvent.startTimeout()\r\n    this.pushBuffer.push(pushEvent)\r\n\r\n    // Enforce buffer size limit\r\n    if (this.pushBuffer.length > MAX_PUSH_BUFFER_SIZE) {\r\n      const removedPush = this.pushBuffer.shift()\r\n      if (removedPush) {\r\n        removedPush.destroy()\r\n        this.socket.log(\r\n          'channel',\r\n          `discarded push due to buffer overflow: ${removedPush.event}`,\r\n          removedPush.payload\r\n        )\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Overridable message hook\r\n   *\r\n   * Receives all events for specialized message handling before dispatching to the channel callbacks.\r\n   * Must return the payload, modified or unmodified.\r\n   *\r\n   * @internal\r\n   */\r\n  _onMessage(_event: string, payload: any, _ref?: string) {\r\n    return payload\r\n  }\r\n\r\n  /** @internal */\r\n  _isMember(topic: string): boolean {\r\n    return this.topic === topic\r\n  }\r\n\r\n  /** @internal */\r\n  _joinRef(): string {\r\n    return this.joinPush.ref\r\n  }\r\n\r\n  /** @internal */\r\n  _trigger(type: string, payload?: any, ref?: string) {\r\n    const typeLower = type.toLocaleLowerCase()\r\n    const { close, error, leave, join } = CHANNEL_EVENTS\r\n    const events: string[] = [close, error, leave, join]\r\n    if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {\r\n      return\r\n    }\r\n    let handledPayload = this._onMessage(typeLower, payload, ref)\r\n    if (payload && !handledPayload) {\r\n      throw 'channel onMessage callbacks must return the payload, modified or unmodified'\r\n    }\r\n\r\n    if (['insert', 'update', 'delete'].includes(typeLower)) {\r\n      this.bindings.postgres_changes\r\n        ?.filter((bind) => {\r\n          return bind.filter?.event === '*' || bind.filter?.event?.toLocaleLowerCase() === typeLower\r\n        })\r\n        .map((bind) => bind.callback(handledPayload, ref))\r\n    } else {\r\n      this.bindings[typeLower]\r\n        ?.filter((bind) => {\r\n          if (['broadcast', 'presence', 'postgres_changes'].includes(typeLower)) {\r\n            if ('id' in bind) {\r\n              const bindId = bind.id\r\n              const bindEvent = bind.filter?.event\r\n              return (\r\n                bindId &&\r\n                payload.ids?.includes(bindId) &&\r\n                (bindEvent === '*' ||\r\n                  bindEvent?.toLocaleLowerCase() === payload.data?.type.toLocaleLowerCase()) &&\r\n                (!bind.filter?.table || bind.filter.table === payload.data?.table)\r\n              )\r\n            } else {\r\n              const bindEvent = bind?.filter?.event?.toLocaleLowerCase()\r\n              return bindEvent === '*' || bindEvent === payload?.event?.toLocaleLowerCase()\r\n            }\r\n          } else {\r\n            return bind.type.toLocaleLowerCase() === typeLower\r\n          }\r\n        })\r\n        .map((bind) => {\r\n          if (typeof handledPayload === 'object' && 'ids' in handledPayload) {\r\n            const postgresChanges = handledPayload.data\r\n            const { schema, table, commit_timestamp, type, errors } = postgresChanges\r\n            const enrichedPayload = {\r\n              schema: schema,\r\n              table: table,\r\n              commit_timestamp: commit_timestamp,\r\n              eventType: type,\r\n              new: {},\r\n              old: {},\r\n              errors: errors,\r\n            }\r\n            handledPayload = {\r\n              ...enrichedPayload,\r\n              ...this._getPayloadRecords(postgresChanges),\r\n            }\r\n          }\r\n          bind.callback(handledPayload, ref)\r\n        })\r\n    }\r\n  }\r\n\r\n  /** @internal */\r\n  _isClosed(): boolean {\r\n    return this.state === CHANNEL_STATES.closed\r\n  }\r\n\r\n  /** @internal */\r\n  _isJoined(): boolean {\r\n    return this.state === CHANNEL_STATES.joined\r\n  }\r\n\r\n  /** @internal */\r\n  _isJoining(): boolean {\r\n    return this.state === CHANNEL_STATES.joining\r\n  }\r\n\r\n  /** @internal */\r\n  _isLeaving(): boolean {\r\n    return this.state === CHANNEL_STATES.leaving\r\n  }\r\n\r\n  /** @internal */\r\n  _replyEventName(ref: string): string {\r\n    return `chan_reply_${ref}`\r\n  }\r\n\r\n  /** @internal */\r\n  _on(type: string, filter: { [key: string]: any }, callback: Function) {\r\n    const typeLower = type.toLocaleLowerCase()\r\n    const binding = {\r\n      type: typeLower,\r\n      filter: filter,\r\n      callback: callback,\r\n    }\r\n\r\n    if (this.bindings[typeLower]) {\r\n      this.bindings[typeLower].push(binding)\r\n    } else {\r\n      this.bindings[typeLower] = [binding]\r\n    }\r\n\r\n    return this\r\n  }\r\n\r\n  /** @internal */\r\n  _off(type: string, filter: { [key: string]: any }) {\r\n    const typeLower = type.toLocaleLowerCase()\r\n\r\n    if (this.bindings[typeLower]) {\r\n      this.bindings[typeLower] = this.bindings[typeLower].filter((bind) => {\r\n        return !(\r\n          bind.type?.toLocaleLowerCase() === typeLower &&\r\n          RealtimeChannel.isEqual(bind.filter, filter)\r\n        )\r\n      })\r\n    }\r\n    return this\r\n  }\r\n\r\n  /** @internal */\r\n  private static isEqual(obj1: { [key: string]: string }, obj2: { [key: string]: string }) {\r\n    if (Object.keys(obj1).length !== Object.keys(obj2).length) {\r\n      return false\r\n    }\r\n\r\n    for (const k in obj1) {\r\n      if (obj1[k] !== obj2[k]) {\r\n        return false\r\n      }\r\n    }\r\n\r\n    return true\r\n  }\r\n\r\n  /**\r\n   * Compares two optional filter values for equality.\r\n   * Treats undefined, null, and empty string as equivalent empty values.\r\n   * @internal\r\n   */\r\n  private static isFilterValueEqual(\r\n    serverValue: string | undefined | null,\r\n    clientValue: string | undefined\r\n  ): boolean {\r\n    const normalizedServer = serverValue ?? undefined\r\n    const normalizedClient = clientValue ?? undefined\r\n    return normalizedServer === normalizedClient\r\n  }\r\n\r\n  /** @internal */\r\n  private _rejoinUntilConnected() {\r\n    this.rejoinTimer.scheduleTimeout()\r\n    if (this.socket.isConnected()) {\r\n      this._rejoin()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Registers a callback that will be executed when the channel closes.\r\n   *\r\n   * @internal\r\n   */\r\n  private _onClose(callback: Function) {\r\n    this._on(CHANNEL_EVENTS.close, {}, callback)\r\n  }\r\n\r\n  /**\r\n   * Registers a callback that will be executed when the channel encounteres an error.\r\n   *\r\n   * @internal\r\n   */\r\n  private _onError(callback: Function) {\r\n    this._on(CHANNEL_EVENTS.error, {}, (reason: string) => callback(reason))\r\n  }\r\n\r\n  /**\r\n   * Returns `true` if the socket is connected and the channel has been joined.\r\n   *\r\n   * @internal\r\n   */\r\n  private _canPush(): boolean {\r\n    return this.socket.isConnected() && this._isJoined()\r\n  }\r\n\r\n  /** @internal */\r\n  private _rejoin(timeout = this.timeout): void {\r\n    if (this._isLeaving()) {\r\n      return\r\n    }\r\n    this.socket._leaveOpenTopic(this.topic)\r\n    this.state = CHANNEL_STATES.joining\r\n    this.joinPush.resend(timeout)\r\n  }\r\n\r\n  /** @internal */\r\n  private _getPayloadRecords(payload: any) {\r\n    const records = {\r\n      new: {},\r\n      old: {},\r\n    }\r\n\r\n    if (payload.type === 'INSERT' || payload.type === 'UPDATE') {\r\n      records.new = Transformers.convertChangeData(payload.columns, payload.record)\r\n    }\r\n\r\n    if (payload.type === 'UPDATE' || payload.type === 'DELETE') {\r\n      records.old = Transformers.convertChangeData(payload.columns, payload.old_record)\r\n    }\r\n\r\n    return records\r\n  }\r\n}\r\n"],"mappings":"AAAA,SAASA,cAAc,EAAEC,cAAc,EAAEC,oBAAoB,QAAQ,iBAAiB;AACtF,OAAOC,IAAI,MAAM,YAAY;AAE7B,OAAOC,KAAK,MAAM,aAAa;AAC/B,OAAOC,gBAAqD,MAAM,oBAAoB;AAMtF,OAAO,KAAKC,YAAY,MAAM,oBAAoB;AAClD,SAASC,eAAe,QAAQ,oBAAoB;AAmHpD,WAAYC,sCAKX;AALD,WAAYA,sCAAsC;EAChDA,sCAAA,aAAS;EACTA,sCAAA,qBAAiB;EACjBA,sCAAA,qBAAiB;EACjBA,sCAAA,qBAAiB;AACnB,CAAC,EALWA,sCAAsC,KAAtCA,sCAAsC;AAOlD,WAAYC,qBAKX;AALD,WAAYA,qBAAqB;EAC/BA,qBAAA,2BAAuB;EACvBA,qBAAA,yBAAqB;EACrBA,qBAAA,yCAAqC;EACrCA,qBAAA,qBAAiB;AACnB,CAAC,EALWA,qBAAqB,KAArBA,qBAAqB;AAOjC,WAAYC,yBAKX;AALD,WAAYA,yBAAyB;EACnCA,yBAAA,6BAAyB;EACzBA,yBAAA,2BAAuB;EACvBA,yBAAA,qBAAiB;EACjBA,yBAAA,mCAA+B;AACjC,CAAC,EALWA,yBAAyB,KAAzBA,yBAAyB;AAOrC,OAAO,MAAMC,uBAAuB,GAAGV,cAAc;AAWrD;;;;;AAKA,eAAc,MAAOW,eAAe;EAoBlC;;;;;;;;;;;;;;;;EAgBAC,YACE;EACOC,KAAa,EACbC,MAAA,GAAiC;IAAEC,MAAM,EAAE;EAAE,CAAE,EAC/CC,MAAsB;;IAFtB,KAAAH,KAAK,GAALA,KAAK;IACL,KAAAC,MAAM,GAANA,MAAM;IACN,KAAAE,MAAM,GAANA,MAAM;IAvCf,KAAAC,QAAQ,GAOJ,EAAE;IAEN,KAAAC,KAAK,GAAmBlB,cAAc,CAACmB,MAAM;IAC7C,KAAAC,UAAU,GAAG,KAAK;IAGlB,KAAAC,UAAU,GAAW,EAAE;IA4BrB,IAAI,CAACC,QAAQ,GAAGT,KAAK,CAACU,OAAO,CAAC,aAAa,EAAE,EAAE,CAAC;IAChD,IAAI,CAACT,MAAM,CAACC,MAAM,GAAAS,MAAA,CAAAC,MAAA,CACb;MACDC,SAAS,EAAE;QAAEC,GAAG,EAAE,KAAK;QAAEC,IAAI,EAAE;MAAK,CAAE;MACtCC,QAAQ,EAAE;QAAEC,GAAG,EAAE,EAAE;QAAEC,OAAO,EAAE;MAAK,CAAE;MACrCC,OAAO,EAAE;KACV,EACElB,MAAM,CAACC,MAAM,CACjB;IACD,IAAI,CAACkB,OAAO,GAAG,IAAI,CAACjB,MAAM,CAACiB,OAAO;IAClC,IAAI,CAACC,QAAQ,GAAG,IAAIhC,IAAI,CAAC,IAAI,EAAEH,cAAc,CAACoC,IAAI,EAAE,IAAI,CAACrB,MAAM,EAAE,IAAI,CAACmB,OAAO,CAAC;IAC9E,IAAI,CAACG,WAAW,GAAG,IAAIjC,KAAK,CAAC,MAAM,IAAI,CAACkC,qBAAqB,EAAE,EAAE,IAAI,CAACrB,MAAM,CAACsB,gBAAgB,CAAC;IAC9F,IAAI,CAACJ,QAAQ,CAACK,OAAO,CAAC,IAAI,EAAE,MAAK;MAC/B,IAAI,CAACrB,KAAK,GAAGlB,cAAc,CAACwC,MAAM;MAClC,IAAI,CAACJ,WAAW,CAACK,KAAK,EAAE;MACxB,IAAI,CAACpB,UAAU,CAACqB,OAAO,CAAEC,SAAe,IAAKA,SAAS,CAACC,IAAI,EAAE,CAAC;MAC9D,IAAI,CAACvB,UAAU,GAAG,EAAE;IACtB,CAAC,CAAC;IACF,IAAI,CAACwB,QAAQ,CAAC,MAAK;MACjB,IAAI,CAACT,WAAW,CAACK,KAAK,EAAE;MACxB,IAAI,CAACzB,MAAM,CAAC8B,GAAG,CAAC,SAAS,EAAE,SAAS,IAAI,CAACjC,KAAK,IAAI,IAAI,CAACkC,QAAQ,EAAE,EAAE,CAAC;MACpE,IAAI,CAAC7B,KAAK,GAAGlB,cAAc,CAACmB,MAAM;MAClC,IAAI,CAACH,MAAM,CAACgC,OAAO,CAAC,IAAI,CAAC;IAC3B,CAAC,CAAC;IACF,IAAI,CAACC,QAAQ,CAAEC,MAAc,IAAI;MAC/B,IAAI,IAAI,CAACC,UAAU,EAAE,IAAI,IAAI,CAACC,SAAS,EAAE,EAAE;QACzC;MACF;MACA,IAAI,CAACpC,MAAM,CAAC8B,GAAG,CAAC,SAAS,EAAE,SAAS,IAAI,CAACjC,KAAK,EAAE,EAAEqC,MAAM,CAAC;MACzD,IAAI,CAAChC,KAAK,GAAGlB,cAAc,CAACqD,OAAO;MACnC,IAAI,CAACjB,WAAW,CAACkB,eAAe,EAAE;IACpC,CAAC,CAAC;IACF,IAAI,CAACpB,QAAQ,CAACK,OAAO,CAAC,SAAS,EAAE,MAAK;MACpC,IAAI,CAAC,IAAI,CAACgB,UAAU,EAAE,EAAE;QACtB;MACF;MACA,IAAI,CAACvC,MAAM,CAAC8B,GAAG,CAAC,SAAS,EAAE,WAAW,IAAI,CAACjC,KAAK,EAAE,EAAE,IAAI,CAACqB,QAAQ,CAACD,OAAO,CAAC;MAC1E,IAAI,CAACf,KAAK,GAAGlB,cAAc,CAACqD,OAAO;MACnC,IAAI,CAACjB,WAAW,CAACkB,eAAe,EAAE;IACpC,CAAC,CAAC;IAEF,IAAI,CAACpB,QAAQ,CAACK,OAAO,CAAC,OAAO,EAAGW,MAAW,IAAI;MAC7C,IAAI,IAAI,CAACC,UAAU,EAAE,IAAI,IAAI,CAACC,SAAS,EAAE,EAAE;QACzC;MACF;MACA,IAAI,CAACpC,MAAM,CAAC8B,GAAG,CAAC,SAAS,EAAE,SAAS,IAAI,CAACjC,KAAK,EAAE,EAAEqC,MAAM,CAAC;MACzD,IAAI,CAAChC,KAAK,GAAGlB,cAAc,CAACqD,OAAO;MACnC,IAAI,CAACjB,WAAW,CAACkB,eAAe,EAAE;IACpC,CAAC,CAAC;IACF,IAAI,CAACE,GAAG,CAACzD,cAAc,CAAC0D,KAAK,EAAE,EAAE,EAAE,CAACC,OAAY,EAAEC,GAAW,KAAI;MAC/D,IAAI,CAACC,QAAQ,CAAC,IAAI,CAACC,eAAe,CAACF,GAAG,CAAC,EAAED,OAAO,CAAC;IACnD,CAAC,CAAC;IAEF,IAAI,CAAC7B,QAAQ,GAAG,IAAIzB,gBAAgB,CAAC,IAAI,CAAC;IAE1C,IAAI,CAAC0D,oBAAoB,GAAGxD,eAAe,CAAC,IAAI,CAACU,MAAM,CAAC+C,QAAQ,CAAC;IACjE,IAAI,CAAC/B,OAAO,GAAG,IAAI,CAAClB,MAAM,CAACC,MAAM,CAACiB,OAAO,IAAI,KAAK;IAElD,IAAI,CAAC,IAAI,CAACA,OAAO,KAAI,CAAAgC,EAAA,IAAAC,EAAA,OAAI,CAACnD,MAAM,CAACC,MAAM,cAAAkD,EAAA,uBAAAA,EAAA,CAAEvC,SAAS,cAAAsC,EAAA,uBAAAA,EAAA,CAAEE,MAAM,GAAE;MAC1D,MAAM,0CAA0C,IAAI,CAACrD,KAAK,kCAAkC;IAC9F;EACF;EAEA;EACAsD,SAASA,CACPC,QAAmE,EACnEnC,OAAO,GAAG,IAAI,CAACA,OAAO;;IAEtB,IAAI,CAAC,IAAI,CAACjB,MAAM,CAACqD,WAAW,EAAE,EAAE;MAC9B,IAAI,CAACrD,MAAM,CAACsD,OAAO,EAAE;IACvB;IACA,IAAI,IAAI,CAACpD,KAAK,IAAIlB,cAAc,CAACmB,MAAM,EAAE;MACvC,MAAM;QACJJ,MAAM,EAAE;UAAEW,SAAS;UAAEG,QAAQ;UAAEG,OAAO,EAAEuC;QAAS;MAAE,CACpD,GAAG,IAAI,CAACzD,MAAM;MAEf,MAAM0D,gBAAgB,GAAG,CAAAR,EAAA,IAAAC,EAAA,OAAI,CAAChD,QAAQ,CAACuD,gBAAgB,cAAAP,EAAA,uBAAAA,EAAA,CAAEQ,GAAG,CAAEC,CAAC,IAAKA,CAAC,CAACC,MAAM,CAAC,cAAAX,EAAA,cAAAA,EAAA,GAAI,EAAE;MAEnF,MAAMY,gBAAgB,GACnB,CAAC,CAAC,IAAI,CAAC3D,QAAQ,CAACT,qBAAqB,CAACqE,QAAQ,CAAC,IAC9C,IAAI,CAAC5D,QAAQ,CAACT,qBAAqB,CAACqE,QAAQ,CAAC,CAACC,MAAM,GAAG,CAAC,IAC1D,EAAAC,EAAA,OAAI,CAACjE,MAAM,CAACC,MAAM,CAACc,QAAQ,cAAAkD,EAAA,uBAAAA,EAAA,CAAEhD,OAAO,MAAK,IAAI;MAC/C,MAAMiD,kBAAkB,GAA8B,EAAE;MACxD,MAAMjE,MAAM,GAAG;QACbW,SAAS;QACTG,QAAQ,EAAAL,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAAOI,QAAQ;UAAEE,OAAO,EAAE6C;QAAgB,EAAE;QACpDJ,gBAAgB;QAChBxC,OAAO,EAAEuC;OACV;MAED,IAAI,IAAI,CAACvD,MAAM,CAACiE,gBAAgB,EAAE;QAChCD,kBAAkB,CAACE,YAAY,GAAG,IAAI,CAAClE,MAAM,CAACiE,gBAAgB;MAChE;MAEA,IAAI,CAAChC,QAAQ,CAAEkC,CAAQ,IAAKf,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAG3D,yBAAyB,CAAC2E,aAAa,EAAED,CAAC,CAAC,CAAC;MAEnF,IAAI,CAACtC,QAAQ,CAAC,MAAMuB,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAG3D,yBAAyB,CAAC4E,MAAM,CAAC,CAAC;MAEjE,IAAI,CAACC,iBAAiB,CAAA9D,MAAA,CAAAC,MAAA,CAAM;QAAEV;MAAM,CAAE,EAAKiE,kBAAkB,EAAG;MAEhE,IAAI,CAAC5D,UAAU,GAAG,IAAI;MACtB,IAAI,CAACmE,OAAO,CAACtD,OAAO,CAAC;MAErB,IAAI,CAACC,QAAQ,CACVK,OAAO,CAAC,IAAI,EAAE,OAAO;QAAEiC;MAAgB,CAA0B,KAAI;;QACpE;QACA,IAAI,CAAC,IAAI,CAACxD,MAAM,CAACwE,cAAc,EAAE,EAAE;UACjC,IAAI,CAACxE,MAAM,CAACyE,OAAO,EAAE;QACvB;QACA,IAAIjB,gBAAgB,KAAKkB,SAAS,EAAE;UAClCtB,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAG3D,yBAAyB,CAACkF,UAAU,CAAC;UAChD;QACF,CAAC,MAAM;UACL,MAAMC,sBAAsB,GAAG,IAAI,CAAC3E,QAAQ,CAACuD,gBAAgB;UAC7D,MAAMqB,WAAW,GAAG,CAAA5B,EAAA,GAAA2B,sBAAsB,aAAtBA,sBAAsB,uBAAtBA,sBAAsB,CAAEd,MAAM,cAAAb,EAAA,cAAAA,EAAA,GAAI,CAAC;UACvD,MAAM6B,mBAAmB,GAAG,EAAE;UAE9B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,WAAW,EAAEE,CAAC,EAAE,EAAE;YACpC,MAAMC,qBAAqB,GAAGJ,sBAAsB,CAACG,CAAC,CAAC;YACvD,MAAM;cACJpB,MAAM,EAAE;gBAAEsB,KAAK;gBAAEC,MAAM;gBAAEC,KAAK;gBAAExB;cAAM;YAAE,CACzC,GAAGqB,qBAAqB;YACzB,MAAMI,oBAAoB,GAAG5B,gBAAgB,IAAIA,gBAAgB,CAACuB,CAAC,CAAC;YAEpE,IACEK,oBAAoB,IACpBA,oBAAoB,CAACH,KAAK,KAAKA,KAAK,IACpCtF,eAAe,CAAC0F,kBAAkB,CAACD,oBAAoB,CAACF,MAAM,EAAEA,MAAM,CAAC,IACvEvF,eAAe,CAAC0F,kBAAkB,CAACD,oBAAoB,CAACD,KAAK,EAAEA,KAAK,CAAC,IACrExF,eAAe,CAAC0F,kBAAkB,CAACD,oBAAoB,CAACzB,MAAM,EAAEA,MAAM,CAAC,EACvE;cACAmB,mBAAmB,CAACQ,IAAI,CAAA9E,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACnBuE,qBAAqB;gBACxBO,EAAE,EAAEH,oBAAoB,CAACG;cAAE,GAC3B;YACJ,CAAC,MAAM;cACL,IAAI,CAACC,WAAW,EAAE;cAClB,IAAI,CAACtF,KAAK,GAAGlB,cAAc,CAACqD,OAAO;cAEnCe,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CACN3D,yBAAyB,CAAC2E,aAAa,EACvC,IAAIqB,KAAK,CAAC,kEAAkE,CAAC,CAC9E;cACD;YACF;UACF;UAEA,IAAI,CAACxF,QAAQ,CAACuD,gBAAgB,GAAGsB,mBAAmB;UAEpD1B,QAAQ,IAAIA,QAAQ,CAAC3D,yBAAyB,CAACkF,UAAU,CAAC;UAC1D;QACF;MACF,CAAC,CAAC,CACDpD,OAAO,CAAC,OAAO,EAAGmE,KAA6B,IAAI;QAClD,IAAI,CAACxF,KAAK,GAAGlB,cAAc,CAACqD,OAAO;QACnCe,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CACN3D,yBAAyB,CAAC2E,aAAa,EACvC,IAAIqB,KAAK,CAACE,IAAI,CAACC,SAAS,CAACpF,MAAM,CAACqF,MAAM,CAACH,KAAK,CAAC,CAACvE,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC,CAAC,CACtE;QACD;MACF,CAAC,CAAC,CACDI,OAAO,CAAC,SAAS,EAAE,MAAK;QACvB6B,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAG3D,yBAAyB,CAACqG,SAAS,CAAC;QAC/C;MACF,CAAC,CAAC;IACN;IACA,OAAO,IAAI;EACb;EAEA;;;;;;EAMAC,aAAaA,CAAA;IACX,OAAO,IAAI,CAAClF,QAAQ,CAACX,KAAiC;EACxD;EAEA;;;;EAIA,MAAM8F,KAAKA,CACTtD,OAA+B,EAC/BuD,IAAA,GAA+B,EAAE;IAEjC,OAAO,MAAM,IAAI,CAACrE,IAAI,CACpB;MACEsE,IAAI,EAAE,UAAU;MAChBjB,KAAK,EAAE,OAAO;MACdvC;KACD,EACDuD,IAAI,CAAChF,OAAO,IAAI,IAAI,CAACA,OAAO,CAC7B;EACH;EAEA;;;EAGA,MAAMkF,OAAOA,CAACF,IAAA,GAA+B,EAAE;IAC7C,OAAO,MAAM,IAAI,CAACrE,IAAI,CACpB;MACEsE,IAAI,EAAE,UAAU;MAChBjB,KAAK,EAAE;KACR,EACDgB,IAAI,CACL;EACH;EAiHAG,EAAEA,CACAF,IAAgC,EAChCvC,MAAgD,EAChDP,QAAgC;IAEhC,IAAI,IAAI,CAAClD,KAAK,KAAKlB,cAAc,CAACwC,MAAM,IAAI0E,IAAI,KAAK1G,qBAAqB,CAACqE,QAAQ,EAAE;MACnF,IAAI,CAAC7D,MAAM,CAAC8B,GAAG,CACb,SAAS,EACT,kBAAkB,IAAI,CAACjC,KAAK,wDAAwD,CACrF;MACD,IAAI,CAAC2F,WAAW,EAAE,CAACa,IAAI,CAAC,YAAY,MAAM,IAAI,CAAClD,SAAS,EAAE,CAAC;IAC7D;IACA,OAAO,IAAI,CAACX,GAAG,CAAC0D,IAAI,EAAEvC,MAAM,EAAEP,QAAQ,CAAC;EACzC;EACA;;;;;;;;;;;EAWA,MAAMkD,QAAQA,CACZrB,KAAa,EACbvC,OAAY,EACZuD,IAAA,GAA6B,EAAE;;IAE/B,IAAIvD,OAAO,KAAKgC,SAAS,IAAIhC,OAAO,KAAK,IAAI,EAAE;MAC7C,OAAO6D,OAAO,CAACC,MAAM,CAAC,oCAAoC,CAAC;IAC7D;IAEA,MAAMC,OAAO,GAA2B;MACtCC,MAAM,EAAE,IAAI,CAAC1G,MAAM,CAAC2G,MAAM,GAAG,IAAI,CAAC3G,MAAM,CAAC2G,MAAM,GAAG,EAAE;MACpD,cAAc,EAAE;KACjB;IAED,IAAI,IAAI,CAAC3G,MAAM,CAACiE,gBAAgB,EAAE;MAChCwC,OAAO,CAAC,eAAe,CAAC,GAAG,UAAU,IAAI,CAACzG,MAAM,CAACiE,gBAAgB,EAAE;IACrE;IAEA,MAAM2C,OAAO,GAAG;MACdC,MAAM,EAAE,MAAM;MACdJ,OAAO;MACPK,IAAI,EAAEnB,IAAI,CAACC,SAAS,CAAC;QACnBmB,QAAQ,EAAE,CACR;UACElH,KAAK,EAAE,IAAI,CAACS,QAAQ;UACpB2E,KAAK;UACLvC,OAAO,EAAEA,OAAO;UAChB1B,OAAO,EAAE,IAAI,CAACA;SACf;OAEJ;KACF;IAED,MAAMgG,QAAQ,GAAG,MAAM,IAAI,CAACC,iBAAiB,CAC3C,IAAI,CAACnE,oBAAoB,EACzB8D,OAAO,EACP,CAAA3D,EAAA,GAAAgD,IAAI,CAAChF,OAAO,cAAAgC,EAAA,cAAAA,EAAA,GAAI,IAAI,CAAChC,OAAO,CAC7B;IAED,IAAI+F,QAAQ,CAACE,MAAM,KAAK,GAAG,EAAE;MAC3B,OAAO;QAAEC,OAAO,EAAE;MAAI,CAAE;IAC1B;IAEA,IAAIC,YAAY,GAAGJ,QAAQ,CAACK,UAAU;IACtC,IAAI;MACF,MAAMC,SAAS,GAAG,MAAMN,QAAQ,CAACO,IAAI,EAAE;MACvCH,YAAY,GAAGE,SAAS,CAAC5B,KAAK,IAAI4B,SAAS,CAACE,OAAO,IAAIJ,YAAY;IACrE,CAAC,CAAC,OAAApE,EAAA,EAAM,CAAC;IAET,OAAOuD,OAAO,CAACC,MAAM,CAAC,IAAIf,KAAK,CAAC2B,YAAY,CAAC,CAAC;EAChD;EAEA;;;;;;;;;EASA,MAAMxF,IAAIA,CACR6F,IAKC,EACDxB,IAAA,GAA+B,EAAE;;IAEjC,IAAI,CAAC,IAAI,CAACyB,QAAQ,EAAE,IAAID,IAAI,CAACvB,IAAI,KAAK,WAAW,EAAE;MACjDyB,OAAO,CAACC,IAAI,CACV,6DAA6D,GAC3D,kDAAkD,GAClD,qDAAqD,CACxD;MAED,MAAM;QAAE3C,KAAK;QAAEvC,OAAO,EAAEmF;MAAgB,CAAE,GAAGJ,IAAI;MACjD,MAAMhB,OAAO,GAA2B;QACtCC,MAAM,EAAE,IAAI,CAAC1G,MAAM,CAAC2G,MAAM,GAAG,IAAI,CAAC3G,MAAM,CAAC2G,MAAM,GAAG,EAAE;QACpD,cAAc,EAAE;OACjB;MAED,IAAI,IAAI,CAAC3G,MAAM,CAACiE,gBAAgB,EAAE;QAChCwC,OAAO,CAAC,eAAe,CAAC,GAAG,UAAU,IAAI,CAACzG,MAAM,CAACiE,gBAAgB,EAAE;MACrE;MAEA,MAAM2C,OAAO,GAAG;QACdC,MAAM,EAAE,MAAM;QACdJ,OAAO;QACPK,IAAI,EAAEnB,IAAI,CAACC,SAAS,CAAC;UACnBmB,QAAQ,EAAE,CACR;YACElH,KAAK,EAAE,IAAI,CAACS,QAAQ;YACpB2E,KAAK;YACLvC,OAAO,EAAEmF,gBAAgB;YACzB7G,OAAO,EAAE,IAAI,CAACA;WACf;SAEJ;OACF;MAED,IAAI;QACF,MAAMgG,QAAQ,GAAG,MAAM,IAAI,CAACC,iBAAiB,CAC3C,IAAI,CAACnE,oBAAoB,EACzB8D,OAAO,EACP,CAAA3D,EAAA,GAAAgD,IAAI,CAAChF,OAAO,cAAAgC,EAAA,cAAAA,EAAA,GAAI,IAAI,CAAChC,OAAO,CAC7B;QAED,OAAM,CAAA+B,EAAA,GAAAgE,QAAQ,CAACF,IAAI,cAAA9D,EAAA,uBAAAA,EAAA,CAAE8E,MAAM,EAAE;QAC7B,OAAOd,QAAQ,CAACe,EAAE,GAAG,IAAI,GAAG,OAAO;MACrC,CAAC,CAAC,OAAOrC,KAAU,EAAE;QACnB,IAAIA,KAAK,CAACsC,IAAI,KAAK,YAAY,EAAE;UAC/B,OAAO,WAAW;QACpB,CAAC,MAAM;UACL,OAAO,OAAO;QAChB;MACF;IACF,CAAC,MAAM;MACL,OAAO,IAAIzB,OAAO,CAAE0B,OAAO,IAAI;;QAC7B,MAAM3C,IAAI,GAAG,IAAI,CAAC4C,KAAK,CAACT,IAAI,CAACvB,IAAI,EAAEuB,IAAI,EAAExB,IAAI,CAAChF,OAAO,IAAI,IAAI,CAACA,OAAO,CAAC;QAEtE,IAAIwG,IAAI,CAACvB,IAAI,KAAK,WAAW,IAAI,EAAC,CAAAnC,EAAA,IAAAf,EAAA,IAAAC,EAAA,OAAI,CAACnD,MAAM,cAAAmD,EAAA,uBAAAA,EAAA,CAAElD,MAAM,cAAAiD,EAAA,uBAAAA,EAAA,CAAEtC,SAAS,cAAAqD,EAAA,uBAAAA,EAAA,CAAEpD,GAAG,GAAE;UACrEsH,OAAO,CAAC,IAAI,CAAC;QACf;QAEA3C,IAAI,CAAC/D,OAAO,CAAC,IAAI,EAAE,MAAM0G,OAAO,CAAC,IAAI,CAAC,CAAC;QACvC3C,IAAI,CAAC/D,OAAO,CAAC,OAAO,EAAE,MAAM0G,OAAO,CAAC,OAAO,CAAC,CAAC;QAC7C3C,IAAI,CAAC/D,OAAO,CAAC,SAAS,EAAE,MAAM0G,OAAO,CAAC,WAAW,CAAC,CAAC;MACrD,CAAC,CAAC;IACJ;EACF;EAEA;;;;EAIA3D,iBAAiBA,CAAC5B,OAA+B;IAC/C,IAAI,CAACxB,QAAQ,CAACiH,aAAa,CAACzF,OAAO,CAAC;EACtC;EAEA;;;;;;;;;EASA8C,WAAWA,CAACvE,OAAO,GAAG,IAAI,CAACA,OAAO;IAChC,IAAI,CAACf,KAAK,GAAGlB,cAAc,CAACoJ,OAAO;IACnC,MAAMC,OAAO,GAAGA,CAAA,KAAK;MACnB,IAAI,CAACrI,MAAM,CAAC8B,GAAG,CAAC,SAAS,EAAE,SAAS,IAAI,CAACjC,KAAK,EAAE,CAAC;MACjD,IAAI,CAAC+C,QAAQ,CAAC7D,cAAc,CAACuJ,KAAK,EAAE,OAAO,EAAE,IAAI,CAACvG,QAAQ,EAAE,CAAC;IAC/D,CAAC;IAED,IAAI,CAACb,QAAQ,CAACqH,OAAO,EAAE;IAEvB,IAAIC,SAAS,GAAgB,IAAI;IAEjC,OAAO,IAAIjC,OAAO,CAA+B0B,OAAO,IAAI;MAC1DO,SAAS,GAAG,IAAItJ,IAAI,CAAC,IAAI,EAAEH,cAAc,CAAC0J,KAAK,EAAE,EAAE,EAAExH,OAAO,CAAC;MAC7DuH,SAAS,CACNjH,OAAO,CAAC,IAAI,EAAE,MAAK;QAClB8G,OAAO,EAAE;QACTJ,OAAO,CAAC,IAAI,CAAC;MACf,CAAC,CAAC,CACD1G,OAAO,CAAC,SAAS,EAAE,MAAK;QACvB8G,OAAO,EAAE;QACTJ,OAAO,CAAC,WAAW,CAAC;MACtB,CAAC,CAAC,CACD1G,OAAO,CAAC,OAAO,EAAE,MAAK;QACrB0G,OAAO,CAAC,OAAO,CAAC;MAClB,CAAC,CAAC;MAEJO,SAAS,CAAC5G,IAAI,EAAE;MAChB,IAAI,CAAC,IAAI,CAAC8F,QAAQ,EAAE,EAAE;QACpBc,SAAS,CAACE,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC;MAC7B;IACF,CAAC,CAAC,CAACC,OAAO,CAAC,MAAK;MACdH,SAAS,aAATA,SAAS,uBAATA,SAAS,CAAED,OAAO,EAAE;IACtB,CAAC,CAAC;EACJ;EACA;;;;;EAKAK,QAAQA,CAAA;IACN,IAAI,CAACvI,UAAU,CAACqB,OAAO,CAAE4D,IAAU,IAAKA,IAAI,CAACiD,OAAO,EAAE,CAAC;IACvD,IAAI,CAAClI,UAAU,GAAG,EAAE;IACpB,IAAI,CAACe,WAAW,CAACK,KAAK,EAAE;IACxB,IAAI,CAACP,QAAQ,CAACqH,OAAO,EAAE;IACvB,IAAI,CAACrI,KAAK,GAAGlB,cAAc,CAACmB,MAAM;IAClC,IAAI,CAACF,QAAQ,GAAG,EAAE;EACpB;EAEA;EAEA,MAAMgH,iBAAiBA,CAAC4B,GAAW,EAAEjC,OAA+B,EAAE3F,OAAe;IACnF,MAAM6H,UAAU,GAAG,IAAIC,eAAe,EAAE;IACxC,MAAMxD,EAAE,GAAGyD,UAAU,CAAC,MAAMF,UAAU,CAACG,KAAK,EAAE,EAAEhI,OAAO,CAAC;IAExD,MAAM+F,QAAQ,GAAG,MAAM,IAAI,CAAChH,MAAM,CAACkJ,KAAK,CAACL,GAAG,EAAArI,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACvCmG,OAAO;MACVuC,MAAM,EAAEL,UAAU,CAACK;IAAM,GACzB;IAEFC,YAAY,CAAC7D,EAAE,CAAC;IAEhB,OAAOyB,QAAQ;EACjB;EAEA;EACAkB,KAAKA,CAACjD,KAAa,EAAEvC,OAA+B,EAAEzB,OAAO,GAAG,IAAI,CAACA,OAAO;IAC1E,IAAI,CAAC,IAAI,CAACb,UAAU,EAAE;MACpB,MAAM,kBAAkB6E,KAAK,SAAS,IAAI,CAACpF,KAAK,iEAAiE;IACnH;IACA,IAAI8B,SAAS,GAAG,IAAIzC,IAAI,CAAC,IAAI,EAAE+F,KAAK,EAAEvC,OAAO,EAAEzB,OAAO,CAAC;IACvD,IAAI,IAAI,CAACyG,QAAQ,EAAE,EAAE;MACnB/F,SAAS,CAACC,IAAI,EAAE;IAClB,CAAC,MAAM;MACL,IAAI,CAACyH,gBAAgB,CAAC1H,SAAS,CAAC;IAClC;IAEA,OAAOA,SAAS;EAClB;EAEA;EACA0H,gBAAgBA,CAAC1H,SAAe;IAC9BA,SAAS,CAAC2H,YAAY,EAAE;IACxB,IAAI,CAACjJ,UAAU,CAACiF,IAAI,CAAC3D,SAAS,CAAC;IAE/B;IACA,IAAI,IAAI,CAACtB,UAAU,CAACyD,MAAM,GAAG7E,oBAAoB,EAAE;MACjD,MAAMsK,WAAW,GAAG,IAAI,CAAClJ,UAAU,CAACmJ,KAAK,EAAE;MAC3C,IAAID,WAAW,EAAE;QACfA,WAAW,CAAChB,OAAO,EAAE;QACrB,IAAI,CAACvI,MAAM,CAAC8B,GAAG,CACb,SAAS,EACT,0CAA0CyH,WAAW,CAACtE,KAAK,EAAE,EAC7DsE,WAAW,CAAC7G,OAAO,CACpB;MACH;IACF;EACF;EAEA;;;;;;;;EAQA+G,UAAUA,CAACC,MAAc,EAAEhH,OAAY,EAAEiH,IAAa;IACpD,OAAOjH,OAAO;EAChB;EAEA;EACAkH,SAASA,CAAC/J,KAAa;IACrB,OAAO,IAAI,CAACA,KAAK,KAAKA,KAAK;EAC7B;EAEA;EACAkC,QAAQA,CAAA;IACN,OAAO,IAAI,CAACb,QAAQ,CAACyB,GAAG;EAC1B;EAEA;EACAC,QAAQA,CAACsD,IAAY,EAAExD,OAAa,EAAEC,GAAY;;IAChD,MAAMkH,SAAS,GAAG3D,IAAI,CAAC4D,iBAAiB,EAAE;IAC1C,MAAM;MAAExB,KAAK;MAAE5C,KAAK;MAAE+C,KAAK;MAAEtH;IAAI,CAAE,GAAGpC,cAAc;IACpD,MAAMgL,MAAM,GAAa,CAACzB,KAAK,EAAE5C,KAAK,EAAE+C,KAAK,EAAEtH,IAAI,CAAC;IACpD,IAAIwB,GAAG,IAAIoH,MAAM,CAACC,OAAO,CAACH,SAAS,CAAC,IAAI,CAAC,IAAIlH,GAAG,KAAK,IAAI,CAACZ,QAAQ,EAAE,EAAE;MACpE;IACF;IACA,IAAIkI,cAAc,GAAG,IAAI,CAACR,UAAU,CAACI,SAAS,EAAEnH,OAAO,EAAEC,GAAG,CAAC;IAC7D,IAAID,OAAO,IAAI,CAACuH,cAAc,EAAE;MAC9B,MAAM,6EAA6E;IACrF;IAEA,IAAI,CAAC,QAAQ,EAAE,QAAQ,EAAE,QAAQ,CAAC,CAACC,QAAQ,CAACL,SAAS,CAAC,EAAE;MACtD,CAAA5G,EAAA,OAAI,CAAChD,QAAQ,CAACuD,gBAAgB,cAAAP,EAAA,uBAAAA,EAAA,CAC1BU,MAAM,CAAEwG,IAAI,IAAI;;QAChB,OAAO,EAAAlH,EAAA,GAAAkH,IAAI,CAACxG,MAAM,cAAAV,EAAA,uBAAAA,EAAA,CAAEgC,KAAK,MAAK,GAAG,IAAI,EAAAlB,EAAA,IAAAf,EAAA,GAAAmH,IAAI,CAACxG,MAAM,cAAAX,EAAA,uBAAAA,EAAA,CAAEiC,KAAK,cAAAlB,EAAA,uBAAAA,EAAA,CAAE+F,iBAAiB,EAAE,MAAKD,SAAS;MAC5F,CAAC,EACApG,GAAG,CAAE0G,IAAI,IAAKA,IAAI,CAAC/G,QAAQ,CAAC6G,cAAc,EAAEtH,GAAG,CAAC,CAAC;IACtD,CAAC,MAAM;MACL,CAAAK,EAAA,OAAI,CAAC/C,QAAQ,CAAC4J,SAAS,CAAC,cAAA7G,EAAA,uBAAAA,EAAA,CACpBW,MAAM,CAAEwG,IAAI,IAAI;;QAChB,IAAI,CAAC,WAAW,EAAE,UAAU,EAAE,kBAAkB,CAAC,CAACD,QAAQ,CAACL,SAAS,CAAC,EAAE;UACrE,IAAI,IAAI,IAAIM,IAAI,EAAE;YAChB,MAAMC,MAAM,GAAGD,IAAI,CAAC5E,EAAE;YACtB,MAAM8E,SAAS,GAAG,CAAApH,EAAA,GAAAkH,IAAI,CAACxG,MAAM,cAAAV,EAAA,uBAAAA,EAAA,CAAEgC,KAAK;YACpC,OACEmF,MAAM,KACN,CAAApH,EAAA,GAAAN,OAAO,CAAC4H,GAAG,cAAAtH,EAAA,uBAAAA,EAAA,CAAEkH,QAAQ,CAACE,MAAM,CAAC,MAC5BC,SAAS,KAAK,GAAG,IAChB,CAAAA,SAAS,aAATA,SAAS,uBAATA,SAAS,CAAEP,iBAAiB,EAAE,OAAK,CAAA/F,EAAA,GAAArB,OAAO,CAAC6H,IAAI,cAAAxG,EAAA,uBAAAA,EAAA,CAAEmC,IAAI,CAAC4D,iBAAiB,EAAE,EAAC,KAC3E,EAAC,CAAAU,EAAA,GAAAL,IAAI,CAACxG,MAAM,cAAA6G,EAAA,uBAAAA,EAAA,CAAErF,KAAK,KAAIgF,IAAI,CAACxG,MAAM,CAACwB,KAAK,MAAK,CAAAsF,EAAA,GAAA/H,OAAO,CAAC6H,IAAI,cAAAE,EAAA,uBAAAA,EAAA,CAAEtF,KAAK,EAAC;UAEtE,CAAC,MAAM;YACL,MAAMkF,SAAS,GAAG,CAAAK,EAAA,IAAAC,EAAA,GAAAR,IAAI,aAAJA,IAAI,uBAAJA,IAAI,CAAExG,MAAM,cAAAgH,EAAA,uBAAAA,EAAA,CAAE1F,KAAK,cAAAyF,EAAA,uBAAAA,EAAA,CAAEZ,iBAAiB,EAAE;YAC1D,OAAOO,SAAS,KAAK,GAAG,IAAIA,SAAS,MAAK,CAAAO,EAAA,GAAAlI,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEuC,KAAK,cAAA2F,EAAA,uBAAAA,EAAA,CAAEd,iBAAiB,EAAE;UAC/E;QACF,CAAC,MAAM;UACL,OAAOK,IAAI,CAACjE,IAAI,CAAC4D,iBAAiB,EAAE,KAAKD,SAAS;QACpD;MACF,CAAC,EACApG,GAAG,CAAE0G,IAAI,IAAI;QACZ,IAAI,OAAOF,cAAc,KAAK,QAAQ,IAAI,KAAK,IAAIA,cAAc,EAAE;UACjE,MAAMY,eAAe,GAAGZ,cAAc,CAACM,IAAI;UAC3C,MAAM;YAAErF,MAAM;YAAEC,KAAK;YAAE2F,gBAAgB;YAAE5E,IAAI;YAAE6E;UAAM,CAAE,GAAGF,eAAe;UACzE,MAAMG,eAAe,GAAG;YACtB9F,MAAM,EAAEA,MAAM;YACdC,KAAK,EAAEA,KAAK;YACZ2F,gBAAgB,EAAEA,gBAAgB;YAClCG,SAAS,EAAE/E,IAAI;YACfgF,GAAG,EAAE,EAAE;YACPC,GAAG,EAAE,EAAE;YACPJ,MAAM,EAAEA;WACT;UACDd,cAAc,GAAAzJ,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACTuK,eAAe,GACf,IAAI,CAACI,kBAAkB,CAACP,eAAe,CAAC,CAC5C;QACH;QACAV,IAAI,CAAC/G,QAAQ,CAAC6G,cAAc,EAAEtH,GAAG,CAAC;MACpC,CAAC,CAAC;IACN;EACF;EAEA;EACAP,SAASA,CAAA;IACP,OAAO,IAAI,CAAClC,KAAK,KAAKlB,cAAc,CAACmB,MAAM;EAC7C;EAEA;EACAkL,SAASA,CAAA;IACP,OAAO,IAAI,CAACnL,KAAK,KAAKlB,cAAc,CAACwC,MAAM;EAC7C;EAEA;EACAe,UAAUA,CAAA;IACR,OAAO,IAAI,CAACrC,KAAK,KAAKlB,cAAc,CAACsM,OAAO;EAC9C;EAEA;EACAnJ,UAAUA,CAAA;IACR,OAAO,IAAI,CAACjC,KAAK,KAAKlB,cAAc,CAACoJ,OAAO;EAC9C;EAEA;EACAvF,eAAeA,CAACF,GAAW;IACzB,OAAO,cAAcA,GAAG,EAAE;EAC5B;EAEA;EACAH,GAAGA,CAAC0D,IAAY,EAAEvC,MAA8B,EAAEP,QAAkB;IAClE,MAAMyG,SAAS,GAAG3D,IAAI,CAAC4D,iBAAiB,EAAE;IAC1C,MAAMyB,OAAO,GAAG;MACdrF,IAAI,EAAE2D,SAAS;MACflG,MAAM,EAAEA,MAAM;MACdP,QAAQ,EAAEA;KACX;IAED,IAAI,IAAI,CAACnD,QAAQ,CAAC4J,SAAS,CAAC,EAAE;MAC5B,IAAI,CAAC5J,QAAQ,CAAC4J,SAAS,CAAC,CAACvE,IAAI,CAACiG,OAAO,CAAC;IACxC,CAAC,MAAM;MACL,IAAI,CAACtL,QAAQ,CAAC4J,SAAS,CAAC,GAAG,CAAC0B,OAAO,CAAC;IACtC;IAEA,OAAO,IAAI;EACb;EAEA;EACAC,IAAIA,CAACtF,IAAY,EAAEvC,MAA8B;IAC/C,MAAMkG,SAAS,GAAG3D,IAAI,CAAC4D,iBAAiB,EAAE;IAE1C,IAAI,IAAI,CAAC7J,QAAQ,CAAC4J,SAAS,CAAC,EAAE;MAC5B,IAAI,CAAC5J,QAAQ,CAAC4J,SAAS,CAAC,GAAG,IAAI,CAAC5J,QAAQ,CAAC4J,SAAS,CAAC,CAAClG,MAAM,CAAEwG,IAAI,IAAI;;QAClE,OAAO,EACL,EAAAlH,EAAA,GAAAkH,IAAI,CAACjE,IAAI,cAAAjD,EAAA,uBAAAA,EAAA,CAAE6G,iBAAiB,EAAE,MAAKD,SAAS,IAC5ClK,eAAe,CAAC8L,OAAO,CAACtB,IAAI,CAACxG,MAAM,EAAEA,MAAM,CAAC,CAC7C;MACH,CAAC,CAAC;IACJ;IACA,OAAO,IAAI;EACb;EAEA;EACQ,OAAO8H,OAAOA,CAACC,IAA+B,EAAEC,IAA+B;IACrF,IAAInL,MAAM,CAACoL,IAAI,CAACF,IAAI,CAAC,CAAC5H,MAAM,KAAKtD,MAAM,CAACoL,IAAI,CAACD,IAAI,CAAC,CAAC7H,MAAM,EAAE;MACzD,OAAO,KAAK;IACd;IAEA,KAAK,MAAM+H,CAAC,IAAIH,IAAI,EAAE;MACpB,IAAIA,IAAI,CAACG,CAAC,CAAC,KAAKF,IAAI,CAACE,CAAC,CAAC,EAAE;QACvB,OAAO,KAAK;MACd;IACF;IAEA,OAAO,IAAI;EACb;EAEA;;;;;EAKQ,OAAOxG,kBAAkBA,CAC/ByG,WAAsC,EACtCC,WAA+B;IAE/B,MAAMC,gBAAgB,GAAGF,WAAW,aAAXA,WAAW,cAAXA,WAAW,GAAIpH,SAAS;IACjD,MAAMuH,gBAAgB,GAAGF,WAAW,aAAXA,WAAW,cAAXA,WAAW,GAAIrH,SAAS;IACjD,OAAOsH,gBAAgB,KAAKC,gBAAgB;EAC9C;EAEA;EACQ5K,qBAAqBA,CAAA;IAC3B,IAAI,CAACD,WAAW,CAACkB,eAAe,EAAE;IAClC,IAAI,IAAI,CAACtC,MAAM,CAACqD,WAAW,EAAE,EAAE;MAC7B,IAAI,CAACkB,OAAO,EAAE;IAChB;EACF;EAEA;;;;;EAKQ1C,QAAQA,CAACuB,QAAkB;IACjC,IAAI,CAACZ,GAAG,CAACzD,cAAc,CAACuJ,KAAK,EAAE,EAAE,EAAElF,QAAQ,CAAC;EAC9C;EAEA;;;;;EAKQnB,QAAQA,CAACmB,QAAkB;IACjC,IAAI,CAACZ,GAAG,CAACzD,cAAc,CAAC2G,KAAK,EAAE,EAAE,EAAGxD,MAAc,IAAKkB,QAAQ,CAAClB,MAAM,CAAC,CAAC;EAC1E;EAEA;;;;;EAKQwF,QAAQA,CAAA;IACd,OAAO,IAAI,CAAC1H,MAAM,CAACqD,WAAW,EAAE,IAAI,IAAI,CAACgI,SAAS,EAAE;EACtD;EAEA;EACQ9G,OAAOA,CAACtD,OAAO,GAAG,IAAI,CAACA,OAAO;IACpC,IAAI,IAAI,CAACkB,UAAU,EAAE,EAAE;MACrB;IACF;IACA,IAAI,CAACnC,MAAM,CAACkM,eAAe,CAAC,IAAI,CAACrM,KAAK,CAAC;IACvC,IAAI,CAACK,KAAK,GAAGlB,cAAc,CAACsM,OAAO;IACnC,IAAI,CAACpK,QAAQ,CAACiL,MAAM,CAAClL,OAAO,CAAC;EAC/B;EAEA;EACQmK,kBAAkBA,CAAC1I,OAAY;IACrC,MAAM0J,OAAO,GAAG;MACdlB,GAAG,EAAE,EAAE;MACPC,GAAG,EAAE;KACN;IAED,IAAIzI,OAAO,CAACwD,IAAI,KAAK,QAAQ,IAAIxD,OAAO,CAACwD,IAAI,KAAK,QAAQ,EAAE;MAC1DkG,OAAO,CAAClB,GAAG,GAAG7L,YAAY,CAACgN,iBAAiB,CAAC3J,OAAO,CAAC4J,OAAO,EAAE5J,OAAO,CAAC6J,MAAM,CAAC;IAC/E;IAEA,IAAI7J,OAAO,CAACwD,IAAI,KAAK,QAAQ,IAAIxD,OAAO,CAACwD,IAAI,KAAK,QAAQ,EAAE;MAC1DkG,OAAO,CAACjB,GAAG,GAAG9L,YAAY,CAACgN,iBAAiB,CAAC3J,OAAO,CAAC4J,OAAO,EAAE5J,OAAO,CAAC8J,UAAU,CAAC;IACnF;IAEA,OAAOJ,OAAO;EAChB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}